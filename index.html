<!doctype html>
<html lang="it">
<head>
<meta charset="utf-8" />
<title>Editor Tracciato - Strada tra Muri (Top-down)</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  html,body{height:100%;margin:0;background:#111;color:#fff;font-family:Arial,Helvetica,sans-serif}
  #container{width:100%;height:100%;position:relative;overflow:hidden}
  .panel{position:absolute;left:12px;top:12px;background:rgba(0,0,0,0.6);padding:10px;border-radius:8px;z-index:10;min-width:260px}
  .panel h3{margin:0 0 6px 0;font-size:14px}
  .panel button,input,label{margin:4px 2px;padding:6px;font-size:13px}
  .hint{position:absolute;right:12px;bottom:12px;background:rgba(0,0,0,0.35);padding:8px;border-radius:6px;font-size:12px}
  #fileInput{display:none}
  .small{font-size:12px;color:#ddd}
</style>
</head>
<body>
<div id="container"></div>

<div class="panel" id="ui">
  <h3>Track Editor (Top-down)</h3>
  <div>
    <button id="btnClear">Clear</button>
    <button id="btnSave">Save</button>
    <button id="btnLoad">Load</button>
    <button id="btnDownload">Download JSON</button>
    <input type="file" id="fileInput" accept=".json">
  </div>
  <div style="margin-top:6px">
    <label>Road Width <input id="roadWidth" type="number" value="7.2" step="0.2" style="width:70px"></label>
    <label>Wall Height <input id="wallHeight" type="number" value="2.0" step="0.1" style="width:70px"></label>
  </div>
  <div style="margin-top:6px">
    <label><input type="checkbox" id="wallsToggle" checked> Walls around road</label>
    <label class="small" title="Distanza muro-carreggiata">Wall gap <input id="wallGap" type="number" value="1.2" step="0.1" style="width:60px"></label>
  </div>
  <div style="margin-top:6px">
    <button id="btnTest">Test Track</button>
    <button id="btnEdit" disabled>Edit Track</button>
  </div>
  <p class="small" style="margin:6px 0 0 0">Click per aggiungere punti; trascina per spostare; seleziona punto e premi Delete per rimuovere.</p>
</div>

<div class="hint">Controls: W/S accelerate/brake, A/D steer; Middle click to change editor camera; Right-drag to orbit</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.154.0/build/three.min.js"></script>

<script>
/* ====== Setup scena ====== */
const container = document.getElementById('container');
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x87ceeb);
const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.shadowMap.enabled = true;
container.appendChild(renderer.domElement);

const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 2000);
camera.up.set(0,1,0);

const hemi = new THREE.HemisphereLight(0xffffff,0x444444,0.9); hemi.position.set(0,50,0); scene.add(hemi);
const dir = new THREE.DirectionalLight(0xffffff,0.8); dir.position.set(-10,20,10); dir.castShadow=true; scene.add(dir);

const ground = new THREE.Mesh(new THREE.PlaneGeometry(2000,2000), new THREE.MeshStandardMaterial({color:0x2b2b2b}));
ground.rotation.x = -Math.PI/2; ground.receiveShadow = true; scene.add(ground);
const grass = new THREE.Mesh(new THREE.PlaneGeometry(2000,2000), new THREE.MeshStandardMaterial({color:0x2e8b57}));
grass.rotation.x = -Math.PI/2; grass.position.y = 0.001; scene.add(grass);

/* ====== Editor state ====== */
let mode = 'edit'; // 'edit' or 'test'
const points = [];
const pointMeshes = [];
let selectedPointIndex = -1;

const lineMaterial = new THREE.LineBasicMaterial({color:0xffff66});
let splineMesh = null;
let roadMesh = null;
let wallMeshes = [];
let centerDashes = [];

const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();
let dragging = false;
let dragIndex = -1;
const plane = new THREE.Plane(new THREE.Vector3(0,1,0), 0);

/* UI */
const btnClear = document.getElementById('btnClear');
const btnSave = document.getElementById('btnSave');
const btnLoad = document.getElementById('btnLoad');
const btnDownload = document.getElementById('btnDownload');
const fileInput = document.getElementById('fileInput');
const btnTest = document.getElementById('btnTest');
const btnEdit = document.getElementById('btnEdit');
const roadWidthInput = document.getElementById('roadWidth');
const wallHeightInput = document.getElementById('wallHeight');
const wallsToggle = document.getElementById('wallsToggle');
const wallGapInput = document.getElementById('wallGap');

btnClear.onclick = () => { clearTrack(); renderEditor(); };
btnSave.onclick = () => { saveToLocal(); };
btnLoad.onclick = () => { loadFromLocal(); renderEditor(); };
btnDownload.onclick = () => { downloadJSON(); };
fileInput.onchange = (e)=> { loadFromFile(e); };
btnTest.onclick = ()=> { enterTestMode(); };
btnEdit.onclick = ()=> { enterEditMode(); };

/* ====== Editor interactions ====== */
function addPointAt(x,z) {
  const p = new THREE.Vector3(x,0,z);
  points.push(p);
  const m = makePointMesh(p);
  pointMeshes.push(m);
  scene.add(m);
}

function makePointMesh(pos) {
  const g = new THREE.SphereGeometry(0.6,12,12);
  const mat = new THREE.MeshStandardMaterial({color:0xff0000});
  const m = new THREE.Mesh(g, mat);
  m.position.copy(pos);
  m.castShadow = true;
  return m;
}

function clearTrack() {
  for (let m of pointMeshes) scene.remove(m);
  pointMeshes.length = 0;
  points.length = 0;
  selectedPointIndex = -1;
  if (splineMesh) { scene.remove(splineMesh); splineMesh = null; }
  if (roadMesh) { scene.remove(roadMesh); roadMesh = null; }
  for (let w of wallMeshes) scene.remove(w);
  wallMeshes.length = 0;
  for (let d of centerDashes) scene.remove(d);
  centerDashes.length = 0;
}

/* Mouse add/drag */
renderer.domElement.addEventListener('pointerdown', (ev)=>{
  if (mode !== 'edit') return;
  const rect = renderer.domElement.getBoundingClientRect();
  mouse.x = ((ev.clientX - rect.left) / rect.width) * 2 - 1;
  mouse.y = -((ev.clientY - rect.top) / rect.height) * 2 + 1;
  raycaster.setFromCamera(mouse, camera);
  const intersect = new THREE.Vector3();
  raycaster.ray.intersectPlane(plane, intersect);
  let found = false;
  for (let i=0;i<pointMeshes.length;i++){
    const m = pointMeshes[i];
    const dist = m.position.distanceTo(intersect);
    if (dist < 1.2) {
      selectedPointIndex = i;
      dragging = true;
      dragIndex = i;
      found = true;
      break;
    }
  }
  if (!found) {
    addPointAt(intersect.x, intersect.z);
    renderEditor();
  }
});

renderer.domElement.addEventListener('pointermove', (ev)=>{
  if (mode !== 'edit') return;
  if (!dragging) return;
  const rect = renderer.domElement.getBoundingClientRect();
  mouse.x = ((ev.clientX - rect.left) / rect.width) * 2 - 1;
  mouse.y = -((ev.clientY - rect.top) / rect.height) * 2 + 1;
  raycaster.setFromCamera(mouse, camera);
  const intersect = new THREE.Vector3();
  raycaster.ray.intersectPlane(plane, intersect);
  if (dragIndex >= 0) {
    points[dragIndex].x = intersect.x;
    points[dragIndex].z = intersect.z;
    pointMeshes[dragIndex].position.copy(points[dragIndex]);
    renderEditor();
  }
});

window.addEventListener('pointerup', ()=>{ dragging=false; dragIndex=-1; });

window.addEventListener('keydown', (e)=>{
  if (mode !== 'edit') return;
  if (e.key === 'Delete' || e.key === 'Backspace') {
    if (selectedPointIndex >= 0) {
      scene.remove(pointMeshes[selectedPointIndex]);
      pointMeshes.splice(selectedPointIndex,1);
      points.splice(selectedPointIndex,1);
      selectedPointIndex = -1;
      renderEditor();
    }
  }
});

/* ====== Render editor: spline, road, optional walls ====== */
function renderEditor() {
  if (splineMesh) { scene.remove(splineMesh); splineMesh = null; }
  if (roadMesh) { scene.remove(roadMesh); roadMesh = null; }
  for (let w of wallMeshes) scene.remove(w); wallMeshes.length=0;
  for (let d of centerDashes) scene.remove(d); centerDashes.length=0;

  if (points.length < 2) return;
  const pts = points.map(p=>p.clone());
  const closed = pts[0].distanceTo(pts[pts.length-1]) < 1.0;
  const curve = new THREE.CatmullRomCurve3(pts, closed, 'catmullrom', 0.5);

  const linePts = curve.getPoints(Math.max(64, pts.length*12));
  const geom = new THREE.BufferGeometry().setFromPoints(linePts);
  const line = new THREE.Line(geom, lineMaterial);
  splineMesh = line;
  scene.add(line);

  const width = parseFloat(roadWidthInput.value) || 7.2;
  const roadGeom = buildRoad(curve, width, 400);
  const roadMat = new THREE.MeshStandardMaterial({color:0x2f2f2f});
  roadMesh = new THREE.Mesh(roadGeom, roadMat);
  roadMesh.receiveShadow = true;
  scene.add(roadMesh);

  // walls around road if enabled
  if (wallsToggle.checked) {
    const wallH = parseFloat(wallHeightInput.value) || 2.0;
    const gap = parseFloat(wallGapInput.value) || 1.2;
    addWallsAlongCurve(curve, width/2 + gap, wallH, 1.0);
    addWallsAlongCurve(curve, -(width/2 + gap), wallH, 1.0);
  }

  addCenterDashes(curve);
}

/* Road builder */
function buildRoad(curve, width, segments) {
  const geometry = new THREE.BufferGeometry();
  const positions = [];
  const normals = [];
  const uvs = [];
  const indices = [];
  const up = new THREE.Vector3(0,1,0);
  for (let i=0;i<=segments;i++){
    const t = i/segments;
    const p = curve.getPointAt(t);
    const tangent = curve.getTangentAt(t).normalize();
    const left = new THREE.Vector3().crossVectors(up, tangent).normalize();
    const half = width/2;
    const pl = p.clone().add(left.clone().multiplyScalar(half));
    const pr = p.clone().add(left.clone().multiplyScalar(-half));
    positions.push(pl.x, pl.y+0.02, pl.z);
    positions.push(pr.x, pr.y+0.02, pr.z);
    normals.push(0,1,0, 0,1,0);
    uvs.push(t*10,0, t*10,1);
    if (i<segments){
      const a = i*2, b = i*2+1, c = (i+1)*2, d = (i+1)*2+1;
      indices.push(a,c,b);
      indices.push(b,c,d);
    }
  }
  geometry.setIndex(indices);
  geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions,3));
  geometry.setAttribute('normal', new THREE.Float32BufferAttribute(normals,3));
  geometry.setAttribute('uv', new THREE.Float32BufferAttribute(uvs,2));
  geometry.computeBoundingBox();
  geometry.computeVertexNormals();
  return geometry;
}

function addWallsAlongCurve(curve, offsetX, height, thickness) {
  const segments = 200;
  for (let i=0;i<segments;i++){
    const t = i/segments;
    const p = curve.getPointAt(t);
    const tangent = curve.getTangentAt(t).normalize();
    const left = new THREE.Vector3().crossVectors(new THREE.Vector3(0,1,0), tangent).normalize();
    const pos = p.clone().add(left.clone().multiplyScalar(offsetX));
    const box = new THREE.Mesh(new THREE.BoxGeometry(thickness, height, 6), new THREE.MeshStandardMaterial({ color:0x666666 }));
    box.position.copy(pos);
    box.lookAt(pos.clone().add(tangent));
    box.position.y = height/2;
    scene.add(box);
    wallMeshes.push(box);
  }
}

function addCenterDashes(curve, dashLen=3, gap=2) {
  const totalLen = curve.getLength();
  let traveled = 0;
  while (traveled < totalLen) {
    const u = traveled / totalLen;
    const t = curve.getUtoTmapping(u);
    const p = curve.getPointAt(t);
    const tangent = curve.getTangentAt(t).normalize();
    const dash = new THREE.Mesh(new THREE.BoxGeometry(0.12,0.02,dashLen), new THREE.MeshStandardMaterial({ color:0xffd24d }));
    dash.position.copy(p).add(new THREE.Vector3(0,0.03,0));
    const yaw = Math.atan2(tangent.x, tangent.z);
    dash.rotation.y = yaw;
    scene.add(dash);
    centerDashes.push(dash);
    traveled += dashLen + gap;
  }
}

/* ====== Save / Load ====== */
function saveToLocal() {
  const data = {
    points: points.map(p=>({x:p.x,z:p.z})),
    roadWidth: parseFloat(roadWidthInput.value),
    wallHeight: parseFloat(wallHeightInput.value),
    wallsEnabled: wallsToggle.checked,
    wallGap: parseFloat(wallGapInput.value)
  };
  localStorage.setItem('trackData', JSON.stringify(data));
  alert('Tracciato salvato in localStorage');
}

function loadFromLocal() {
  const raw = localStorage.getItem('trackData');
  if (!raw) { alert('Nessun tracciato salvato'); return; }
  const data = JSON.parse(raw);
  applyTrackData(data);
}

function downloadJSON() {
  const data = {
    points: points.map(p=>({x:p.x,z:p.z})),
    roadWidth: parseFloat(roadWidthInput.value),
    wallHeight: parseFloat(wallHeightInput.value),
    wallsEnabled: wallsToggle.checked,
    wallGap: parseFloat(wallGapInput.value)
  };
  const blob = new Blob([JSON.stringify(data, null, 2)], {type:'application/json'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url; a.download = 'track.json'; a.click();
  URL.revokeObjectURL(url);
}

function loadFromFile(e) {
  const f = e.target.files[0];
  if (!f) return;
  const reader = new FileReader();
  reader.onload = ()=> {
    const data = JSON.parse(reader.result);
    applyTrackData(data);
    renderEditor();
  };
  reader.readAsText(f);
}

function applyTrackData(data) {
  clearTrack();
  if (!data || !data.points) return;
  for (let pt of data.points) addPointAt(pt.x, pt.z);
  roadWidthInput.value = data.roadWidth || roadWidthInput.value;
  wallHeightInput.value = data.wallHeight || wallHeightInput.value;
  wallsToggle.checked = data.wallsEnabled !== undefined ? data.wallsEnabled : wallsToggle.checked;
  wallGapInput.value = data.wallGap !== undefined ? data.wallGap : wallGapInput.value;
}

/* ====== Test mode (spawn & simple physics) ====== */
let player, ai, playerState, aiState, wallBoxes = [], centerline = [];
function enterTestMode() {
  if (points.length < 2) { alert('Disegna almeno 2 punti per il tracciato'); return; }
  mode = 'test';
  btnTest.disabled = true; btnEdit.disabled = false;
  for (let m of pointMeshes) m.visible = false;
  const pts = points.map(p=>p.clone());
  const closed = pts[0].distanceTo(pts[pts.length-1]) < 1.0;
  const curve = new THREE.CatmullRomCurve3(pts, closed, 'catmullrom', 0.5);
  centerline = [];
  const samples = 2400;
  for (let i=0;i<samples;i++){
    const t = i/samples;
    const p = curve.getPointAt(t);
    centerline.push(new THREE.Vector3(p.x,0,p.z));
  }
  // compute wallBoxes for simple collision (only if walls exist)
  wallBoxes = wallMeshes.map(w => new THREE.Box3().setFromObject(w));
  spawnVehicles(curve);
}

function enterEditMode() {
  mode = 'edit';
  btnTest.disabled = false; btnEdit.disabled = true;
  if (player) { scene.remove(player); player = null; }
  if (ai) { scene.remove(ai); ai = null; }
  for (let m of pointMeshes) m.visible = true;
  // set editor camera top-down immediately
  editorCameraIndex = 0;
  applyEditorCameraImmediate();
}

/* spawn vehicles */
function spawnVehicles(curve) {
  if (player) scene.remove(player);
  if (ai) scene.remove(ai);

  player = new THREE.Group();
  const startT = 0.02;
  const startP = curve.getPointAt(startT);
  const startTan = curve.getTangentAt(startT).normalize();
  player.position.set(startP.x, 0.5, startP.z);
  player.rotation.y = Math.atan2(startTan.x, startTan.z);
  const body = new THREE.Mesh(new THREE.BoxGeometry(2.2,0.5,4), new THREE.MeshStandardMaterial({color:0x0055ff}));
  body.position.y = 0.4; player.add(body);
  scene.add(player);

  ai = new THREE.Group();
  const aiT = (startT + 0.85) % 1.0;
  const aiP = curve.getPointAt(aiT);
  const aiTan = curve.getTangentAt(aiT).normalize();
  ai.position.set(aiP.x, 0.5, aiP.z);
  ai.rotation.y = Math.atan2(aiTan.x, aiTan.z);
  const aiBody = new THREE.Mesh(new THREE.BoxGeometry(2.2,0.5,4), new THREE.MeshStandardMaterial({color:0xff5500}));
  aiBody.position.y = 0.4; ai.add(aiBody);
  scene.add(ai);

  playerState = {velocity:0, heading:player.rotation.y, steerAngle:0};
  aiState = {speed:6, index: Math.floor(centerline.length*0.85)};

  cameraMode = 'hood';
  applyCameraModeImmediate();
}

/* ====== Editor camera modes (middle click cycles) ====== */
let editorCameraIndex = 0; // 0 top, 1 orbit, 2 close
const editorTop = {pos: new THREE.Vector3(0,120,0), look: new THREE.Vector3(0,0,0)};
const editorOrbit = {pos: new THREE.Vector3(0,60,120), look: new THREE.Vector3(0,0,0)};
const editorClose = {pos: new THREE.Vector3(0,18,60), look: new THREE.Vector3(0,0,0)};

function applyEditorCameraImmediate() {
  if (editorCameraIndex === 0) {
    camera.position.copy(editorTop.pos);
    camera.lookAt(editorTop.look);
  } else if (editorCameraIndex === 1) {
    camera.position.copy(editorOrbit.pos);
    camera.lookAt(editorOrbit.look);
  } else {
    camera.position.copy(editorClose.pos);
    camera.lookAt(editorClose.look);
  }
}

function updateEditorCameraSmooth(dt) {
  if (editorCameraIndex === 0) {
    camera.position.lerp(editorTop.pos, dt*4);
    camera.lookAt(editorTop.look);
  } else if (editorCameraIndex === 1) {
    camera.position.lerp(editorOrbit.pos, dt*4);
    camera.lookAt(editorOrbit.look);
  } else {
    camera.position.lerp(editorClose.pos, dt*4);
    camera.lookAt(editorClose.look);
  }
}

/* Orbit controls in editor (right-drag) */
let orbitYaw = 0, orbitPitch = 0, orbitDistance = 120;
let orbitDragging = false, orbitLast = {x:0,y:0};
renderer.domElement.addEventListener('contextmenu', (e)=>{ if (mode==='edit') e.preventDefault(); });
renderer.domElement.addEventListener('mousedown', (e)=>{
  if (e.button === 1) { // middle click cycles camera modes
    if (mode === 'edit') {
      editorCameraIndex = (editorCameraIndex + 1) % 3;
      applyEditorCameraImmediate();
    } else {
      // in test mode handled separately
      if (cameraMode === 'hood') cameraMode = 'third';
      else if (cameraMode === 'third') cameraMode = 'top';
      else cameraMode = 'hood';
      applyCameraModeImmediate();
    }
  }
  if (mode === 'edit' && e.button === 2) {
    orbitDragging = true;
    orbitLast.x = e.clientX; orbitLast.y = e.clientY;
  }
});
window.addEventListener('mousemove', (e)=>{
  if (mode === 'edit' && orbitDragging) {
    const dx = (e.clientX - orbitLast.x) * 0.005;
    const dy = (e.clientY - orbitLast.y) * 0.005;
    orbitYaw += dx;
    orbitPitch = Math.max(-1.2, Math.min(1.2, orbitPitch + dy));
    orbitLast.x = e.clientX; orbitLast.y = e.clientY;
    const center = new THREE.Vector3(0,0,0);
    const x = Math.sin(orbitYaw) * orbitDistance * Math.cos(orbitPitch);
    const y = Math.sin(orbitPitch) * orbitDistance;
    const z = Math.cos(orbitYaw) * orbitDistance * Math.cos(orbitPitch);
    editorOrbit.pos.set(x, Math.max(6,y), z);
    editorOrbit.look.copy(center);
    applyEditorCameraImmediate();
  }
});
window.addEventListener('mouseup', ()=>{ orbitDragging = false; });

// zoom with wheel in editor
renderer.domElement.addEventListener('wheel', (e)=>{
  if (mode === 'edit') {
    orbitDistance = Math.max(20, Math.min(400, orbitDistance + e.deltaY * 0.1));
    const x = Math.sin(orbitYaw) * orbitDistance * Math.cos(orbitPitch);
    const y = Math.sin(orbitPitch) * orbitDistance;
    const z = Math.cos(orbitYaw) * orbitDistance * Math.cos(orbitPitch);
    editorOrbit.pos.set(x, Math.max(6,y), z);
    applyEditorCameraImmediate();
    e.preventDefault();
  }
}, {passive:false});

/* ====== Test controls & camera ====== */
const input = {forward:false,back:false,left:false,right:false,brake:false};
window.addEventListener('keydown', (e)=>{
  if (mode !== 'test') return;
  if (e.code === 'KeyW' || e.code === 'ArrowUp') input.forward = true;
  if (e.code === 'KeyS' || e.code === 'ArrowDown') input.back = true;
  if (e.code === 'KeyA' || e.code === 'ArrowLeft') input.left = true;
  if (e.code === 'KeyD' || e.code === 'ArrowRight') input.right = true;
  if (e.code === 'Space') input.brake = true;
});
window.addEventListener('keyup', (e)=>{
  if (mode !== 'test') return;
  if (e.code === 'KeyW' || e.code === 'ArrowUp') input.forward = false;
  if (e.code === 'KeyS' || e.code === 'ArrowDown') input.back = false;
  if (e.code === 'KeyA' || e.code === 'ArrowLeft') input.left = false;
  if (e.code === 'KeyD' || e.code === 'ArrowRight') input.right = false;
  if (e.code === 'Space') input.brake = false;
});

let cameraMode = 'hood';
const hoodOffset = new THREE.Vector3(0,1.05,2.2);
const hoodLook = new THREE.Vector3(0,0.6,12);
const thirdOffset = new THREE.Vector3(0,3.6,-8.5);
const thirdLook = new THREE.Vector3(0,1.2,12);

function applyCameraModeImmediate() {
  if (!player) return;
  if (cameraMode === 'hood') {
    camera.position.copy(player.localToWorld(hoodOffset.clone()));
    camera.lookAt(player.localToWorld(hoodLook.clone()));
  } else if (cameraMode === 'third') {
    camera.position.copy(player.localToWorld(thirdOffset.clone()));
    camera.lookAt(player.localToWorld(thirdLook.clone()));
  } else if (cameraMode === 'top') {
    const topPos = player.position.clone().add(new THREE.Vector3(0,40,0));
    camera.position.copy(topPos);
    camera.lookAt(player.position.clone());
  }
}

function updateCameraSmooth(dt) {
  if (mode === 'edit') updateEditorCameraSmooth(dt);
  else {
    if (!player) return;
    if (cameraMode === 'hood') {
      const desired = player.localToWorld(hoodOffset.clone());
      camera.position.lerp(desired, dt*8);
      const look = player.localToWorld(hoodLook.clone());
      camera.lookAt(look);
    } else if (cameraMode === 'third') {
      const desired = player.localToWorld(thirdOffset.clone());
      camera.position.lerp(desired, dt*6);
      const look = player.localToWorld(thirdLook.clone());
      camera.lookAt(look);
    } else {
      const desired = player.position.clone().add(new THREE.Vector3(0,40,0));
      camera.position.lerp(desired, dt*4);
      camera.lookAt(player.position.clone());
    }
  }
}

/* ====== Simple physics (player & AI) ====== */
function updatePlayerPhysics(dt) {
  if (!playerState) return;
  const maxSteer = THREE.MathUtils.degToRad(28);
  const wheelbase = 2.6;
  const maxSpeedMs = 160/3.6;
  const accel = 28, brakeDecel = 80, drag = 1.8;

  let throttle = 0;
  if (input.forward && !input.back) throttle = 1;
  else if (input.back && !input.forward) throttle = -0.6;
  else throttle = 0;

  if (input.brake) {
    if (playerState.velocity > 0) playerState.velocity -= brakeDecel * dt;
    else playerState.velocity = Math.max(playerState.velocity - brakeDecel*dt, -maxSpeedMs*0.5);
  } else {
    playerState.velocity += throttle * accel * dt;
    const dragForce = drag * playerState.velocity * Math.abs(playerState.velocity) * 0.02;
    playerState.velocity -= dragForce * dt;
  }
  playerState.velocity = THREE.MathUtils.clamp(playerState.velocity, -maxSpeedMs*0.6, maxSpeedMs);

  let steerInput = 0;
  if (input.left && !input.right) steerInput = 1;
  else if (input.right && !input.left) steerInput = -1;
  else steerInput = 0;

  const speedFactor = 1 - Math.min(1, Math.abs(playerState.velocity) / maxSpeedMs);
  const targetSteer = steerInput * maxSteer * (0.6 + 0.4*speedFactor);
  playerState.steerAngle = THREE.MathUtils.lerp(playerState.steerAngle || 0, targetSteer, dt*8);

  const dHeading = (playerState.velocity / Math.max(0.0001, wheelbase)) * Math.tan(playerState.steerAngle || 0);
  playerState.heading += dHeading * dt;

  const forward = new THREE.Vector3(Math.sin(playerState.heading),0,Math.cos(playerState.heading));
  player.position.addScaledVector(forward, playerState.velocity * dt);
  player.rotation.y = playerState.heading;

  // collision: distance-based to centerline (robusto per piste spline)
  if (centerline.length > 0) {
    const res = findNearestOnCenterline(player.position, centerline);
    const roadHalf = (parseFloat(roadWidthInput.value) || 7.2) / 2;
    const wallMargin = parseFloat(wallGapInput.value) || 1.2;
    const lateralAbs = Math.abs(res.lateral);
    if (lateralAbs > roadHalf + wallMargin) {
      // hit wall
      player.position.addScaledVector(forward, -Math.max(0.08, Math.abs(playerState.velocity) * 0.02));
      playerState.velocity *= -0.18;
    } else if (lateralAbs > roadHalf) {
      // on grass
      playerState.velocity *= 0.96;
    }
  }

  // keep constant height to avoid micro-dossi
  player.position.y = 0.5;
}

function updateAIPhysics(dt) {
  if (!aiState) return;
  const lookahead = 22;
  let idx = aiState.index;
  const targetIdx = (idx + lookahead) % centerline.length;
  const target = centerline[targetIdx];
  const toTarget = new THREE.Vector3(target.x - ai.position.x, 0, target.z - ai.position.z);
  const dist = toTarget.length();
  if (dist < 1.2) aiState.index = (aiState.index + 1) % centerline.length;

  const desiredDir = toTarget.clone().normalize();
  const desiredYaw = Math.atan2(desiredDir.x, desiredDir.z);
  let yawDiff = Math.atan2(Math.sin(desiredYaw - ai.rotation.y), Math.cos(desiredYaw - ai.rotation.y));

  const nextIdx = (targetIdx + 8) % centerline.length;
  const nextPoint = centerline[nextIdx];
  const futureDir = new THREE.Vector3(nextPoint.x - target.x, 0, nextPoint.z - target.z).normalize();
  const angleBetween = Math.acos(THREE.MathUtils.clamp(desiredDir.dot(futureDir), -1, 1));
  const curveFactor = Math.min(1, angleBetween / (Math.PI/4));
  const targetSpeed = THREE.MathUtils.lerp(14, 6, curveFactor);

  if (aiState.speed < targetSpeed) aiState.speed += 10 * dt;
  else aiState.speed -= 12 * dt;
  aiState.speed = THREE.MathUtils.clamp(aiState.speed, 6, 14);

  let avoid = false;
  const aiBox = new THREE.Box3().setFromObject(ai);
  for (let wb of wallBoxes) {
    const expanded = wb.clone().expandByScalar(1.6);
    if (aiBox.intersectsBox(expanded)) { avoid = true; break; }
  }
  if (avoid) {
    aiState.speed *= 0.55;
    yawDiff += (Math.random()>0.5?1:-1)*0.6;
  }

  const maxYawRate = dt * 3.0;
  yawDiff = THREE.MathUtils.clamp(yawDiff, -maxYawRate, maxYawRate);
  ai.rotation.y += yawDiff;

  const forward = new THREE.Vector3(Math.sin(ai.rotation.y),0,Math.cos(ai.rotation.y));
  ai.position.addScaledVector(forward, aiState.speed * dt);

  // keep ai height constant
  ai.position.y = 0.5;
}

/* helper: nearest on centerline */
function findNearestOnCenterline(pos, centerlineArr) {
  let bestIdx = 0;
  let bestDist = Infinity;
  for (let i = 0; i < centerlineArr.length; i++) {
    const d = pos.distanceTo(centerlineArr[i]);
    if (d < bestDist) { bestDist = d; bestIdx = i; }
  }
  const next = centerlineArr[(bestIdx + 5) % centerlineArr.length];
  const prev = centerlineArr[(bestIdx - 5 + centerlineArr.length) % centerlineArr.length];
  const tangent = next.clone().sub(prev).normalize();
  const left = new THREE.Vector3().crossVectors(new THREE.Vector3(0,1,0), tangent).normalize();
  const vecToCar = pos.clone().sub(centerlineArr[bestIdx]);
  const lateral = vecToCar.dot(left);
  return { index: bestIdx, point: centerlineArr[bestIdx].clone(), tangent, lateral };
}

/* ====== Animation loop ====== */
const clock = new THREE.Clock();
function animate(){
  const dt = Math.min(0.05, clock.getDelta());
  if (mode === 'edit') {
    updateEditorCameraSmooth(dt);
    renderer.render(scene, camera);
  } else {
    updatePlayerPhysics(dt);
    updateAIPhysics(dt);
    updateCameraSmooth(dt);
    renderer.render(scene, camera);
  }
  requestAnimationFrame(animate);
}
animate();

/* ====== Utilities ====== */
function download(filename, text) {
  const blob = new Blob([text], {type:'text/plain'});
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = filename;
  a.click();
  URL.revokeObjectURL(a.href);
}

/* ====== Initialize with sample Monaco-like layout and top-down editor view ====== */
(function seedSample(){
  const sample = [
    {x:0,z:-220},{x:0,z:-160},{x:12,z:-130},{x:28,z:-100},{x:36,z:-60},
    {x:30,z:-20},{x:18,z:10},{x:6,z:36},{x:-6,z:60},{x:-28,z:80},
    {x:-48,z:60},{x:-56,z:20},{x:-48,z:-20},{x:-30,z:-60},{x:-12,z:-100},{x:6,z:-140},{x:0,z:-220}
  ];
  for (let p of sample) addPointAt(p.x,p.z);
  renderEditor();
  // set editor camera top-down by default
  editorCameraIndex = 0;
  applyEditorCameraImmediate();
})();
</script>
</body>
</html>
