<!doctype html>
<html lang="it">
<head>
<meta charset="utf-8" />
<title>3D Track Editor - Road + Zoom</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  html,body{height:100%;margin:0;background:#111;color:#fff;font-family:Arial,Helvetica,sans-serif}
  #container{width:100%;height:100%;position:relative;overflow:hidden}
  .panel{position:absolute;left:12px;top:12px;background:rgba(0,0,0,0.75);padding:10px;border-radius:8px;z-index:20;min-width:320px}
  .panel h3{margin:0 0 6px 0;font-size:14px}
  .panel button,input,label,select{margin:4px 2px;padding:6px;font-size:13px}
  .hint{position:absolute;right:12px;bottom:12px;background:rgba(0,0,0,0.35);padding:8px;border-radius:6px;font-size:12px;z-index:20}
  .small{font-size:12px;color:#ddd}
  .speed { position:absolute; right:12px; top:12px; z-index:21; background:rgba(0,0,0,0.6); padding:8px 10px; border-radius:8px; font-weight:700; color:#ffd700; display:none; }
  .modeBadge { position:absolute; left:12px; bottom:12px; z-index:21; background:rgba(0,0,0,0.6); padding:6px 8px; border-radius:6px; font-size:13px; }
  .row { display:flex; align-items:center; gap:6px; flex-wrap:wrap; }
  .panel .row > * { flex: none; }
</style>
</head>
<body>
<div id="container"></div>

<div class="panel" id="ui">
  <h3>Track Editor</h3>

  <div class="row">
    <button id="btnClear">Clear</button>
    <button id="btnSave">Save</button>
    <button id="btnLoad">Load</button>
    <button id="btnDownload">Download JSON</button>
    <input type="file" id="fileInput" accept=".json">
  </div>

  <div style="margin-top:6px" class="row">
    <label>Road Width <input id="roadWidth" type="number" value="7.2" step="0.2" style="width:80px"></label>
    <label>Wall Height <input id="wallHeight" type="number" value="2.0" step="0.1" style="width:80px"></label>
    <label>Wall Gap <input id="wallGap" type="number" value="1.2" step="0.1" style="width:80px"></label>
  </div>

  <div style="margin-top:6px" class="row">
    <label><input type="checkbox" id="autoWalls" checked> Auto Walls</label>
    <label><input type="checkbox" id="showRoad" checked> Show Road</label>
  </div>

  <div style="margin-top:6px" class="row">
    <button id="modePlaceWalls">Place Manual Walls</button>
    <button id="modePlaceBillboards">Place Billboards</button>
    <button id="modePlaceRoadWalls">Place Road Walls</button>
    <button id="modeSetSpawn">Set Spawn</button>
    <button id="btnTest">Test Track</button>
    <button id="btnEdit" disabled>Edit Track</button>
  </div>

  <div style="margin-top:8px" class="row">
    <strong>Editor Zoom</strong>
    <button id="zoomIn">+</button>
    <button id="zoomOut">âˆ’</button>
    <span class="small">o usa rotella / tasti + -</span>
  </div>

  <p class="small" style="margin-top:8px">Click per aggiungere punti; trascina per spostare; seleziona punto e premi Delete per rimuovere. Premi V per nascondere/mostrare il pannello.</p>
</div>

<div id="speedHud" class="speed">Speed: 0 km/h</div>
<div id="modeBadge" class="modeBadge">Editor</div>
<div class="hint">Controls: W/S accelerate/brake, A/D steer; Middle click to change editor camera; Right-drag to orbit</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.154.0/build/three.min.js"></script>

<script>
/* ====== Basic scene setup ====== */
const container = document.getElementById('container');
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x87ceeb);
const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.shadowMap.enabled = true;
container.appendChild(renderer.domElement);

const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 2000);
camera.position.set(0, 120, 120);
camera.lookAt(0,0,0);

const hemi = new THREE.HemisphereLight(0xffffff,0x444444,0.9); hemi.position.set(0,50,0); scene.add(hemi);
const dir = new THREE.DirectionalLight(0xffffff,0.8); dir.position.set(-10,20,10); dir.castShadow=true; scene.add(dir);

const groundMat = new THREE.MeshStandardMaterial({color:0x2b2b2b});
const ground = new THREE.Mesh(new THREE.PlaneGeometry(2000,2000), groundMat);
ground.rotation.x = -Math.PI/2; ground.receiveShadow = true; scene.add(ground);

const grassMat = new THREE.MeshStandardMaterial({color:0x2e8b57});
const grass = new THREE.Mesh(new THREE.PlaneGeometry(2000,2000), grassMat);
grass.rotation.x = -Math.PI/2; grass.position.y = 0.001; scene.add(grass);

/* ====== Editor state ====== */
let mode = 'edit';
const points = [];
const pointMeshes = [];
let selectedPointIndex = -1;

let splineMesh = null;
let roadMesh = null;
let centerDashes = [];

const manualEntities = [];
let autoWallGroup = new THREE.Group(); scene.add(autoWallGroup);

const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();
let dragging = false;
let dragIndex = -1;
const plane = new THREE.Plane(new THREE.Vector3(0,1,0), 0);

/* UI refs */
const btnClear = document.getElementById('btnClear');
const btnSave = document.getElementById('btnSave');
const btnLoad = document.getElementById('btnLoad');
const btnDownload = document.getElementById('btnDownload');
const fileInput = document.getElementById('fileInput');
const btnTest = document.getElementById('btnTest');
const btnEdit = document.getElementById('btnEdit');
const roadWidthInput = document.getElementById('roadWidth');
const wallHeightInput = document.getElementById('wallHeight');
const wallsToggle = document.getElementById('autoWalls');
const wallGapInput = document.getElementById('wallGap');
const modePlaceWalls = document.getElementById('modePlaceWalls');
const modePlaceBillboards = document.getElementById('modePlaceBillboards');
const modePlaceRoadWallsBtn = document.getElementById('modePlaceRoadWalls');
const modeSetSpawn = document.getElementById('modeSetSpawn');
const zoomInBtn = document.getElementById('zoomIn');
const zoomOutBtn = document.getElementById('zoomOut');
const showRoadCheckbox = document.getElementById('showRoad');

btnClear.onclick = () => { clearTrack(); renderEditor(); };
btnSave.onclick = () => { saveToLocal(); };
btnLoad.onclick = () => { loadFromLocal(); renderEditor(); };
btnDownload.onclick = () => { downloadJSON(); };
fileInput.onchange = (e)=> { loadFromFile(e); };
btnTest.onclick = ()=> { enterTestMode(); };
btnEdit.onclick = ()=> { enterEditMode(); };

modePlaceWalls.onclick = ()=> setPlaceMode('manualWall');
modePlaceBillboards.onclick = ()=> setPlaceMode('billboard');
modePlaceRoadWallsBtn.onclick = ()=> setPlaceMode('roadWall');
modeSetSpawn.onclick = ()=> setPlaceMode('setSpawn');

zoomInBtn.addEventListener('click', editorZoomIn);
zoomOutBtn.addEventListener('click', editorZoomOut);

/* ====== Road material (visible gray, double sided) ====== */
const roadMaterial = new THREE.MeshStandardMaterial({
  color: 0x555555,
  metalness: 0.05,
  roughness: 0.85,
  side: THREE.DoubleSide
});
const dashMaterial = new THREE.MeshStandardMaterial({color:0xffd24d});

/* ====== Basic helpers ====== */
function addPointAt(x,z) {
  const p = new THREE.Vector3(x,0,z);
  points.push(p);
  const m = makePointMesh(p);
  pointMeshes.push(m);
  scene.add(m);
}

function makePointMesh(pos) {
  const g = new THREE.SphereGeometry(0.6,12,12);
  const mat = new THREE.MeshStandardMaterial({color:0xff0000});
  const m = new THREE.Mesh(g, mat);
  m.position.copy(pos);
  m.castShadow = true;
  return m;
}

function clearTrack() {
  for (let m of pointMeshes) scene.remove(m);
  pointMeshes.length = 0;
  points.length = 0;
  selectedPointIndex = -1;
  if (splineMesh) { scene.remove(splineMesh); splineMesh = null; }
  if (roadMesh) { scene.remove(roadMesh); roadMesh = null; }
  for (let d of centerDashes) scene.remove(d); centerDashes.length=0;
  while (autoWallGroup.children.length) autoWallGroup.remove(autoWallGroup.children[0]);
  for (let e of manualEntities) scene.remove(e.mesh);
  manualEntities.length = 0;
}

/* ====== Mouse interactions (editor) ====== */
renderer.domElement.addEventListener('pointerdown', (ev)=>{
  if (mode !== 'edit') return;
  const rect = renderer.domElement.getBoundingClientRect();
  mouse.x = ((ev.clientX - rect.left) / rect.width) * 2 - 1;
  mouse.y = -((ev.clientY - rect.top) / rect.height) * 2 + 1;
  raycaster.setFromCamera(mouse, camera);
  const intersect = new THREE.Vector3();
  raycaster.ray.intersectPlane(plane, intersect);

  // place modes
  if (placeMode === 'manualWall') { placeManualEntity('wall', intersect); return; }
  if (placeMode === 'billboard') { placeManualEntity('billboard', intersect); return; }
  if (placeMode === 'setSpawn') {
    const curve = buildCurveFromPoints();
    if (!curve) { alert('Disegna prima il tracciato'); return; }
    spawnT = findClosestUOnCurve(curve, intersect);
    spawnPoint = curve.getPointAt(spawnT);
    alert('Spawn impostato');
    setPlaceMode('none');
    return;
  }
  if (placeMode === 'roadWall') {
    const curve = buildCurveFromPoints();
    if (!curve) { alert('Disegna prima il tracciato'); return; }
    const u = findClosestUOnCurve(curve, intersect);
    const p = curve.getPointAt(u);
    const tan = curve.getTangentAt(u).normalize();
    const left = new THREE.Vector3().crossVectors(new THREE.Vector3(0,1,0), tan).normalize();
    const gap = parseFloat(wallGapInput.value) || 1.2;
    const roadHalf = (parseFloat(roadWidthInput.value) || 7.2) / 2;
    const nearest = findNearestOnCenterline(p, curve.getPoints(200));
    const side = (nearest && nearest.lateral < 0) ? -1 : 1;
    const offset = left.clone().multiplyScalar(side * (roadHalf + gap));
    const pos = p.clone().add(offset);
    const wallH = parseFloat(wallHeightInput.value) || 2.0;
    const wallLen = 6;
    const wallThickness = 1.0;
    const box = new THREE.Mesh(new THREE.BoxGeometry(wallThickness, wallH, wallLen), new THREE.MeshStandardMaterial({color:0x666666}));
    box.position.copy(pos);
    box.lookAt(pos.clone().add(tan));
    box.position.y = wallH/2;
    scene.add(box);
    manualEntities.push({mesh: box, type:'roadWall', params:{height:wallH, length:wallLen, thickness:wallThickness, side}});
    renderEditor();
    return;
  }

  // select or add point
  let found = false;
  for (let i=0;i<pointMeshes.length;i++){
    const m = pointMeshes[i];
    const dist = m.position.distanceTo(intersect);
    if (dist < 1.2) {
      selectedPointIndex = i;
      dragging = true;
      dragIndex = i;
      found = true;
      break;
    }
  }
  if (!found) {
    addPointAt(intersect.x, intersect.z);
    renderEditor();
  }
});

renderer.domElement.addEventListener('pointermove', (ev)=>{
  if (mode !== 'edit') return;
  if (!dragging) return;
  const rect = renderer.domElement.getBoundingClientRect();
  mouse.x = ((ev.clientX - rect.left) / rect.width) * 2 - 1;
  mouse.y = -((ev.clientY - rect.top) / rect.height) * 2 + 1;
  raycaster.setFromCamera(mouse, camera);
  const intersect = new THREE.Vector3();
  raycaster.ray.intersectPlane(plane, intersect);
  if (dragIndex >= 0) {
    points[dragIndex].x = intersect.x;
    points[dragIndex].z = intersect.z;
    pointMeshes[dragIndex].position.copy(points[dragIndex]);
    renderEditor();
  }
});

window.addEventListener('pointerup', ()=>{ dragging=false; dragIndex=-1; });

window.addEventListener('keydown', (e)=>{
  if (mode === 'edit') {
    if (e.key === 'Delete' || e.key === 'Backspace') {
      if (selectedPointIndex >= 0) {
        scene.remove(pointMeshes[selectedPointIndex]);
        pointMeshes.splice(selectedPointIndex,1);
        points.splice(selectedPointIndex,1);
        selectedPointIndex = -1;
        renderEditor();
      }
    }
    if (e.key === '+' || e.key === '=') editorZoomIn();
    if (e.key === '-') editorZoomOut();
  }
  if (e.key.toLowerCase() === 'v') {
    const panel = document.querySelector('.panel');
    if (panel) panel.style.display = panel.style.display === 'none' ? 'block' : 'none';
  }
});

/* ====== Render spline and road ====== */
function renderEditor() {
  if (splineMesh) { scene.remove(splineMesh); splineMesh = null; }
  if (roadMesh) { scene.remove(roadMesh); roadMesh = null; }
  for (let d of centerDashes) scene.remove(d); centerDashes.length=0;
  while (autoWallGroup.children.length) autoWallGroup.remove(autoWallGroup.children[0]);

  if (points.length < 2) return;
  const curve = buildCurveFromPoints();
  if (!curve) return;

  const linePts = curve.getPoints(Math.max(64, points.length*12));
  const geom = new THREE.BufferGeometry().setFromPoints(linePts);
  const line = new THREE.Line(geom, new THREE.LineBasicMaterial({color:0xffff66}));
  splineMesh = line;
  scene.add(line);

  if (showRoadCheckbox.checked) {
    const width = parseFloat(roadWidthInput.value) || 7.2;
    const roadGeom = buildRoad(curve, width, 600);
    if (roadGeom) {
      roadMesh = new THREE.Mesh(roadGeom, roadMaterial);
      roadMesh.receiveShadow = true;
      roadMesh.position.y = 0.02; // lift to avoid z-fighting
      roadMesh.renderOrder = 1;
      scene.add(roadMesh);
    }
  }

  addCenterDashes(curve);

  if (wallsToggle.checked) {
    const wallH = parseFloat(wallHeightInput.value) || 2.0;
    const gap = parseFloat(wallGapInput.value) || 1.2;
    addAutoWalls(curve, (parseFloat(roadWidthInput.value)||7.2)/2 + gap, wallH, 1.0);
  }
}

/* Road builder */
function buildRoad(curve, width, segments) {
  const geometry = new THREE.BufferGeometry();
  const positions = [];
  const normals = [];
  const uvs = [];
  const indices = [];
  const up = new THREE.Vector3(0,1,0);
  for (let i=0;i<=segments;i++){
    const t = i/segments;
    const p = curve.getPointAt(t);
    const tangent = curve.getTangentAt(t).normalize();
    const left = new THREE.Vector3().crossVectors(up, tangent).normalize();
    const half = width/2;
    const pl = p.clone().add(left.clone().multiplyScalar(half));
    const pr = p.clone().add(left.clone().multiplyScalar(-half));
    positions.push(pl.x, pl.y+0.02, pl.z);
    positions.push(pr.x, pr.y+0.02, pr.z);
    normals.push(0,1,0, 0,1,0);
    uvs.push(t*10,0, t*10,1);
    if (i<segments){
      const a = i*2, b = i*2+1, c = (i+1)*2, d = (i+1)*2+1;
      indices.push(a,c,b);
      indices.push(b,c,d);
    }
  }
  geometry.setIndex(indices);
  geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions,3));
  geometry.setAttribute('normal', new THREE.Float32BufferAttribute(normals,3));
  geometry.setAttribute('uv', new THREE.Float32BufferAttribute(uvs,2));
  geometry.computeBoundingBox();
  geometry.computeVertexNormals();
  return geometry;
}

/* Center dashes */
function addCenterDashes(curve, dashLen=3, gap=2) {
  const totalLen = curve.getLength();
  let traveled = 0;
  while (traveled < totalLen) {
    const u = traveled / totalLen;
    const t = curve.getUtoTmapping(u);
    const p = curve.getPointAt(t);
    const tangent = curve.getTangentAt(t).normalize();
    const dash = new THREE.Mesh(new THREE.BoxGeometry(0.12,0.02,dashLen), dashMaterial);
    dash.position.copy(p).add(new THREE.Vector3(0,0.03,0));
    const yaw = Math.atan2(tangent.x, tangent.z);
    dash.rotation.y = yaw;
    scene.add(dash);
    centerDashes.push(dash);
    traveled += dashLen + gap;
  }
}

/* Auto walls */
function addAutoWalls(curve, offsetX, height, thickness) {
  const segments = 200;
  for (let i=0;i<segments;i++){
    const t = i/segments;
    const p = curve.getPointAt(t);
    const tangent = curve.getTangentAt(t).normalize();
    const left = new THREE.Vector3().crossVectors(new THREE.Vector3(0,1,0), tangent).normalize();
    const posL = p.clone().add(left.clone().multiplyScalar(offsetX));
    const posR = p.clone().add(left.clone().multiplyScalar(-offsetX));
    const boxL = new THREE.Mesh(new THREE.BoxGeometry(thickness, height, 6), new THREE.MeshStandardMaterial({ color:0x666666 }));
    boxL.position.copy(posL); boxL.lookAt(posL.clone().add(tangent)); boxL.position.y = height/2;
    autoWallGroup.add(boxL);
    const boxR = boxL.clone();
    boxR.position.copy(posR); boxR.lookAt(posR.clone().add(tangent)); boxR.position.y = height/2;
    autoWallGroup.add(boxR);
  }
}

/* Manual entities */
function placeManualEntity(type, worldPos) {
  const h = parseFloat(wallHeightInput.value) || 2.0;
  const len = 6;
  if (type === 'wall') {
    const mesh = new THREE.Mesh(new THREE.BoxGeometry(1.0, h, len), new THREE.MeshStandardMaterial({color:0x777777}));
    mesh.position.copy(worldPos); mesh.position.y = h/2;
    scene.add(mesh);
    manualEntities.push({mesh, type:'wall', params:{height:h, length:len}});
  } else if (type === 'billboard') {
    const mesh = new THREE.Mesh(new THREE.BoxGeometry(0.6, 1.2, 0.2), new THREE.MeshStandardMaterial({color:0xffcc66}));
    mesh.position.copy(worldPos); mesh.position.y = 0.6;
    scene.add(mesh);
    manualEntities.push({mesh, type:'billboard', params:{height:1.2, length:0.2}});
  }
}

/* ====== Simple curve helpers ====== */
function buildCurveFromPoints() {
  if (points.length < 2) return null;
  const pts = points.map(p=>p.clone());
  const closed = pts[0].distanceTo(pts[pts.length-1]) < 1.0;
  return new THREE.CatmullRomCurve3(pts, closed, 'catmullrom', 0.5);
}

function findClosestUOnCurve(curve, worldPos, samples=400) {
  let bestU = 0; let bestD = Infinity;
  for (let i=0;i<=samples;i++){
    const u = i/samples;
    const p = curve.getPointAt(u);
    const d = p.distanceTo(worldPos);
    if (d < bestD) { bestD = d; bestU = u; }
  }
  return bestU;
}

function findNearestOnCenterline(pos, centerlineArr) {
  let bestIdx = 0; let bestDist = Infinity;
  for (let i=0;i<centerlineArr.length;i++){
    const d = pos.distanceTo(centerlineArr[i]);
    if (d < bestDist) { bestDist = d; bestIdx = i; }
  }
  const next = centerlineArr[(bestIdx + 5) % centerlineArr.length];
  const prev = centerlineArr[(bestIdx - 5 + centerlineArr.length) % centerlineArr.length];
  const tangent = next.clone().sub(prev).normalize();
  const left = new THREE.Vector3().crossVectors(new THREE.Vector3(0,1,0), tangent).normalize();
  const vecToCar = pos.clone().sub(centerlineArr[bestIdx]);
  const lateral = vecToCar.dot(left);
  return { index: bestIdx, point: centerlineArr[bestIdx].clone(), tangent, lateral };
}

/* ====== Zoom controls (editor) ====== */
let editorYaw = 0, editorPitch = 0, editorDistance = 120;
let editorOrbit = { pos: new THREE.Vector3(0,60,120), look: new THREE.Vector3(0,0,0) };

function editorZoomIn() {
  editorDistance = Math.max(20, editorDistance - 8);
  const x = Math.sin(editorYaw) * editorDistance * Math.cos(editorPitch);
  const y = Math.sin(editorPitch) * editorDistance;
  const z = Math.cos(editorYaw) * editorDistance * Math.cos(editorPitch);
  editorOrbit.pos.set(x, Math.max(6,y), z);
  camera.position.copy(editorOrbit.pos);
  camera.lookAt(editorOrbit.look);
}

function editorZoomOut() {
  editorDistance = Math.min(400, editorDistance + 8);
  const x = Math.sin(editorYaw) * editorDistance * Math.cos(editorPitch);
  const y = Math.sin(editorPitch) * editorDistance;
  const z = Math.cos(editorYaw) * editorDistance * Math.cos(editorPitch);
  editorOrbit.pos.set(x, Math.max(6,y), z);
  camera.position.copy(editorOrbit.pos);
  camera.lookAt(editorOrbit.look);
}

/* ====== Place mode and spawn ====== */
let placeMode = 'none';
let spawnT = 0.02;
let spawnPoint = null;
function setPlaceMode(m) {
  placeMode = m;
  const badge = document.getElementById('modeBadge');
  if (m === 'manualWall') badge.textContent = 'Place Manual Walls';
  else if (m === 'billboard') badge.textContent = 'Place Billboards';
  else if (m === 'roadWall') badge.textContent = 'Place Road Walls';
  else if (m === 'setSpawn') badge.textContent = 'Set Spawn';
  else badge.textContent = (mode==='edit' ? 'Editor' : 'Test');
}

/* ====== Save / Load ====== */
function saveToLocal() {
  const data = {
    points: points.map(p=>({x:p.x,z:p.z})),
    roadWidth: parseFloat(roadWidthInput.value),
    wallHeight: parseFloat(wallHeightInput.value),
    wallsEnabled: wallsToggle.checked,
    wallGap: parseFloat(wallGapInput.value),
    manualEntities: manualEntities.map(e => ({
      type: e.type,
      pos: {x:e.mesh.position.x, y:e.mesh.position.y, z:e.mesh.position.z},
      params: e.params
    })),
    spawnT
  };
  localStorage.setItem('trackData', JSON.stringify(data));
  alert('Tracciato salvato');
}

function loadFromLocal() {
  const raw = localStorage.getItem('trackData');
  if (!raw) { alert('Nessun tracciato salvato'); return; }
  const data = JSON.parse(raw);
  applyTrackData(data);
}

function downloadJSON() {
  const data = {
    points: points.map(p=>({x:p.x,z:p.z})),
    roadWidth: parseFloat(roadWidthInput.value),
    wallHeight: parseFloat(wallHeightInput.value),
    wallsEnabled: wallsToggle.checked,
    wallGap: parseFloat(wallGapInput.value),
    manualEntities: manualEntities.map(e => ({
      type: e.type,
      pos: {x:e.mesh.position.x, y:e.mesh.position.y, z:e.mesh.position.z},
      params: e.params
    })),
    spawnT
  };
  const blob = new Blob([JSON.stringify(data, null, 2)], {type:'application/json'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url; a.download = 'track.json'; a.click();
  URL.revokeObjectURL(url);
}

function loadFromFile(e) {
  const f = e.target.files[0];
  if (!f) return;
  const reader = new FileReader();
  reader.onload = ()=> {
    const data = JSON.parse(reader.result);
    applyTrackData(data);
    renderEditor();
  };
  reader.readAsText(f);
}

function applyTrackData(data) {
  clearTrack();
  if (!data || !data.points) return;
  for (let pt of data.points) addPointAt(pt.x, pt.z);
  roadWidthInput.value = data.roadWidth || roadWidthInput.value;
  wallHeightInput.value = data.wallHeight || wallHeightInput.value;
  wallsToggle.checked = data.wallsEnabled !== undefined ? data.wallsEnabled : wallsToggle.checked;
  wallGapInput.value = data.wallGap !== undefined ? data.wallGap : wallGapInput.value;
  if (data.manualEntities && data.manualEntities.length) {
    for (let me of data.manualEntities) {
      const mesh = (me.type==='wall' || me.type==='roadWall') ? new THREE.Mesh(new THREE.BoxGeometry(1.0, me.params.height, me.params.length), new THREE.MeshStandardMaterial({color:0x777777}))
                                      : new THREE.Mesh(new THREE.BoxGeometry(0.6, me.params.height, me.params.length), new THREE.MeshStandardMaterial({color:0xffcc66}));
      mesh.position.set(me.pos.x, me.pos.y, me.pos.z);
      scene.add(mesh);
      manualEntities.push({mesh, type:me.type, params:me.params});
    }
  }
  spawnT = data.spawnT !== undefined ? data.spawnT : spawnT;
}

/* ====== Simple animation loop ====== */
const clock = new THREE.Clock();
function animate(){
  const dt = Math.min(0.05, clock.getDelta());
  renderer.render(scene, camera);
  requestAnimationFrame(animate);
}
animate();

/* ====== Initialize sample track and set editor camera ====== */
(function seedSample(){
  const sample = [
    {x:0,z:-220},{x:0,z:-160},{x:12,z:-130},{x:28,z:-100},{x:36,z:-60},
    {x:30,z:-20},{x:18,z:10},{x:6,z:36},{x:-6,z:60},{x:-28,z:80},
    {x:-48,z:60},{x:-56,z:20},{x:-48,z:-20},{x:-30,z:-60},{x:-12,z:-100},{x:6,z:-140},{x:0,z:-220}
  ];
  for (let p of sample) addPointAt(p.x,p.z);
  renderEditor();
  // set camera to editor orbit pos
  editorOrbit.pos.set(0,60,120);
  camera.position.copy(editorOrbit.pos);
  camera.lookAt(editorOrbit.look);
})();
</script>
</body>
</html>
