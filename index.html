<!doctype html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <title>F1 3D - Road Version (HTML/CSS/JS)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    html,body { height:100%; margin:0; background:#111; font-family:Arial,Helvetica,sans-serif; }
    #container { width:100%; height:100%; display:block; position:relative; overflow:hidden; }
    .ui {
      position: absolute; left:12px; top:12px; color:#fff; z-index:10;
      background:rgba(0,0,0,0.4); padding:10px 12px; border-radius:8px;
      box-shadow:0 4px 12px rgba(0,0,0,0.6);
    }
    .ui h1 { margin:0 0 6px 0; font-size:14px; font-weight:700; letter-spacing:0.5px; }
    .ui p { margin:4px 0; font-size:13px; }
    .ui .big { font-size:18px; font-weight:700; color:#ffd700; }
    .hint { position:absolute; right:12px; bottom:12px; color:#ddd; background:rgba(0,0,0,0.35); padding:8px 10px; border-radius:6px; font-size:12px; }
  </style>
</head>
<body>
  <div id="container"></div>

  <div class="ui" id="hud">
    <h1>F1 3D Road Prototype</h1>
    <p><span class="big" id="speed">Speed: 0 km/h</span></p>
    <p id="lap">Lap: 0 / 3</p>
    <p id="status">Status: Ready</p>
  </div>

  <div class="hint">Controls: W/S accelerate, A/D steer, Space brake</div>

  <script src="https://cdn.jsdelivr.net/npm/three@0.154.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.154.0/examples/js/controls/OrbitControls.js"></script>

  <script>
  // Scene, renderer, camera
  const container = document.getElementById('container');
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x87ceeb);

  const renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.shadowMap.enabled = true;
  container.appendChild(renderer.domElement);

  const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
  camera.position.set(0, 6, -18);

  const hemi = new THREE.HemisphereLight(0xffffff, 0x444444, 0.9);
  hemi.position.set(0, 50, 0);
  scene.add(hemi);

  const dir = new THREE.DirectionalLight(0xffffff, 0.8);
  dir.position.set(-10, 20, 10);
  dir.castShadow = true;
  dir.shadow.mapSize.set(2048,2048);
  scene.add(dir);

  // Ground
  const groundMat = new THREE.MeshStandardMaterial({ color: 0x2b2b2b });
  const ground = new THREE.Mesh(new THREE.PlaneGeometry(400, 400), groundMat);
  ground.rotation.x = -Math.PI/2;
  ground.receiveShadow = true;
  scene.add(ground);

  // ====== ROAD: create a long straight road with lane markings and shoulders ======
  const roadGroup = new THREE.Group();
  scene.add(roadGroup);

  // Road geometry (long rectangle)
  const roadWidth = 10;      // total road width (meters)
  const laneCount = 2;       // lanes per direction (visual)
  const roadLength = 220;    // length of the road
  const asphaltMat = new THREE.MeshStandardMaterial({ color: 0x2f2f2f, roughness: 0.9, metalness: 0.05 });
  const roadGeom = new THREE.PlaneGeometry(roadWidth, roadLength, 1, 1);
  roadGeom.rotateX(-Math.PI/2);
  const roadMesh = new THREE.Mesh(roadGeom, asphaltMat);
  roadMesh.receiveShadow = true;
  roadGroup.add(roadMesh);

  // Road position (centered)
  roadMesh.position.set(0, 0.01, 0);

  // Add lane markings using thin boxes
  function addLine(z, width, color, dash=false) {
    if (!dash) {
      const mat = new THREE.MeshStandardMaterial({ color: color, emissive: color, emissiveIntensity: 0.2 });
      const g = new THREE.BoxGeometry(width, 0.02,  roadLength);
      const m = new THREE.Mesh(g, mat);
      m.position.set(0, 0.02, z);
      m.receiveShadow = true;
      roadGroup.add(m);
    } else {
      // dashed center line: create repeated small boxes
      const dashLen = 4;
      const gap = 3;
      const count = Math.ceil(roadLength / (dashLen + gap));
      for (let i=0;i<count;i++){
        const mat = new THREE.MeshStandardMaterial({ color: color, emissive: color, emissiveIntensity: 0.2 });
        const g = new THREE.BoxGeometry(width, 0.02, dashLen);
        const m = new THREE.Mesh(g, mat);
        const zpos = -roadLength/2 + i*(dashLen+gap) + dashLen/2;
        m.position.set(0, 0.02, zpos);
        roadGroup.add(m);
      }
    }
  }

  // Outer white edge lines
  addLine( (roadWidth/2) - 0.15, 0.12, 0xffffff );
  addLine( -(roadWidth/2) + 0.15, 0.12, 0xffffff );

  // Center dashed yellow line
  addLine(0, 0.12, 0xffd24d, true);

  // Shoulders (gravel/grass) as thin strips
  const shoulderMat = new THREE.MeshStandardMaterial({ color: 0x556b2f });
  const shoulderLeft = new THREE.Mesh(new THREE.PlaneGeometry(6, roadLength), shoulderMat);
  shoulderLeft.rotation.x = -Math.PI/2;
  shoulderLeft.position.set(-(roadWidth/2 + 3), 0.01, 0);
  roadGroup.add(shoulderLeft);

  const shoulderRight = shoulderLeft.clone();
  shoulderRight.position.set((roadWidth/2 + 3), 0.01, 0);
  roadGroup.add(shoulderRight);

  // Add simple guardrails as thin boxes along the road edges
  const railMat = new THREE.MeshStandardMaterial({ color: 0x888888, metalness:0.6, roughness:0.4 });
  function addRail(x) {
    const rail = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.6, roadLength), railMat);
    rail.position.set(x, 0.35, 0);
    roadGroup.add(rail);
  }
  addRail(-(roadWidth/2 + 1.5));
  addRail((roadWidth/2 + 1.5));

  // Slight elevation so car sits above road
  roadGroup.position.y = 0;

  // ====== Centerline path for AI and lap detection (straight + loop at end) ======
  const centerline = [];
  // straight segment
  for (let i=0;i<120;i++){
    centerline.push(new THREE.Vector3(0, 0, -roadLength/2 + i * (roadLength/120)));
  }
  // loop at far end (semi-circle) to return
  const loopRadius = roadWidth * 1.8;
  const loopCenterZ = roadLength/2;
  for (let i=0;i<64;i++){
    const t = (i/63) * Math.PI; // semi circle
    const x = Math.cos(t) * loopRadius;
    const z = loopCenterZ + Math.sin(t) * loopRadius;
    centerline.push(new THREE.Vector3(x, 0, z));
  }
  // return straight back
  for (let i=0;i<120;i++){
    centerline.push(new THREE.Vector3(0, 0, roadLength/2 - i * (roadLength/120)));
  }

  // ====== Car (player) ======
  const car = new THREE.Group();
  car.position.set(0, 0.5, -roadLength/2 + 6);
  scene.add(car);

  const bodyMat = new THREE.MeshStandardMaterial({ color: 0x0055ff, metalness:0.3, roughness:0.4 });
  const body = new THREE.Mesh(new THREE.BoxGeometry(2.2,0.5,4), bodyMat);
  body.castShadow = true;
  body.position.y = 0.4;
  car.add(body);

  const cockpit = new THREE.Mesh(new THREE.BoxGeometry(1.2,0.4,1.2), new THREE.MeshStandardMaterial({ color:0x111111 }));
  cockpit.position.set(0,0.65,0.2);
  cockpit.castShadow = true;
  car.add(cockpit);

  const wheelMat = new THREE.MeshStandardMaterial({ color:0x111111 });
  function makeWheel(x,z){
    const w = new THREE.Mesh(new THREE.CylinderGeometry(0.35,0.35,0.4,16), wheelMat);
    w.rotation.z = Math.PI/2;
    w.position.set(x,0.2,z);
    w.castShadow = true;
    car.add(w);
    return w;
  }
  const wfl = makeWheel(-0.95,1.4);
  const wfr = makeWheel(0.95,1.4);
  const wrl = makeWheel(-0.95,-1.4);
  const wrr = makeWheel(0.95,-1.4);

  // Camera follow
  const camOffset = new THREE.Vector3(0, 4.2, -8);
  const camLookOffset = new THREE.Vector3(0, 1.2, 0);

  // Simple kinematic driving variables
  let velocity = 0;
  let heading = 0;
  let steerAngle = 0;
  const maxSteer = THREE.MathUtils.degToRad(28);
  const maxSpeed = 120;
  const maxSpeedMs = maxSpeed / 3.6;
  const accel = 22;
  const brakeDecel = 50;
  const drag = 1.8;
  const grip = 6.0;

  const input = { forward:false, back:false, left:false, right:false, brake:false };
  window.addEventListener('keydown', (e)=>{
    if (e.code === 'KeyW') input.forward = true;
    if (e.code === 'KeyS') input.back = true;
    if (e.code === 'KeyA') input.left = true;
    if (e.code === 'KeyD') input.right = true;
    if (e.code === 'Space') input.brake = true;
  });
  window.addEventListener('keyup', (e)=>{
    if (e.code === 'KeyW') input.forward = false;
    if (e.code === 'KeyS') input.back = false;
    if (e.code === 'KeyA') input.left = false;
    if (e.code === 'KeyD') input.right = false;
    if (e.code === 'Space') input.brake = false;
  });

  const speedEl = document.getElementById('speed');
  const lapEl = document.getElementById('lap');
  const statusEl = document.getElementById('status');

  // Lap detection: start line near initial position
  const startZ = car.position.z;
  let laps = 0;
  const totalLaps = 3;
  let lastZ = car.position.z;

  // Simple AI car following centerline
  const ai = new THREE.Group();
  scene.add(ai);
  const aiBody = new THREE.Mesh(new THREE.BoxGeometry(2.2,0.5,4), new THREE.MeshStandardMaterial({ color:0xff5500 }));
  aiBody.position.y = 0.4;
  ai.add(aiBody);
  ai.position.set(0,0.5, -roadLength/2 + 20);
  let aiIndex = 0;
  let aiSpeed = 10;

  window.addEventListener('resize', ()=> {
    renderer.setSize(window.innerWidth, window.innerHeight);
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
  });

  const clock = new THREE.Clock();

  function animate(){
    const dt = Math.min(0.05, clock.getDelta());

    // Player input
    let throttle = 0;
    if (input.forward) throttle += 1;
    if (input.back) throttle -= 0.6;

    if (input.brake) {
      if (velocity > 0) velocity -= brakeDecel * dt;
      else velocity = Math.max(velocity - brakeDecel*dt, -maxSpeedMs*0.5);
    } else {
      velocity += throttle * accel * dt;
      const dragForce = drag * velocity * Math.abs(velocity) * 0.02;
      velocity -= dragForce * dt;
    }

    velocity = THREE.MathUtils.clamp(velocity, -maxSpeedMs*0.6, maxSpeedMs);

    let steerInput = 0;
    if (input.left) steerInput = 1;
    if (input.right) steerInput = -1;
    const speedFactor = 1 - Math.min(1, Math.abs(velocity)/maxSpeedMs);
    steerAngle = THREE.MathUtils.lerp(steerAngle, steerInput * maxSteer * (0.6 + 0.4*speedFactor), dt*6);

    const turnRadius = 1.0 / Math.max(0.0001, Math.tan(steerAngle));
    const angularVel = (velocity / Math.max(1, Math.abs(turnRadius))) * (steerAngle === 0 ? 0 : Math.sign(steerAngle));
    heading += angularVel * dt * (grip * 0.02);

    const forwardVec = new THREE.Vector3(Math.sin(heading), 0, Math.cos(heading));
    car.position.addScaledVector(forwardVec, velocity * dt);
    car.rotation.y = heading;

    const wheelSpin = velocity * dt * 6;
    wfl.rotation.x -= wheelSpin;
    wfr.rotation.x -= wheelSpin;
    wrl.rotation.x -= wheelSpin;
    wrr.rotation.x -= wheelSpin;

    // Camera smoothing
    const desiredCamPos = car.localToWorld(camOffset.clone());
    camera.position.lerp(desiredCamPos, dt*4);
    const lookAt = car.localToWorld(camLookOffset.clone());
    camera.lookAt(lookAt);

    // HUD
    const kmh = Math.round(velocity * 3.6);
    speedEl.textContent = `Speed: ${kmh} km/h`;

    // Lap detection crossing startZ (simple)
    const prevZ = lastZ;
    lastZ = car.position.z;
    if (prevZ < startZ && car.position.z >= startZ && Math.abs(car.position.x) < roadWidth/2) {
      laps++;
      lapEl.textContent = `Lap: ${laps} / ${totalLaps}`;
      if (laps >= totalLaps) {
        statusEl.textContent = 'Status: Race Finished';
        velocity = 0;
      } else {
        statusEl.textContent = `Status: Lap ${laps} completed`;
        setTimeout(()=> statusEl.textContent = 'Status: Racing', 1200);
      }
    }

    // Off-road penalty
    const distFromCenter = Math.abs(car.position.x);
    if (distFromCenter > roadWidth/2 + 2.5) {
      velocity *= 0.96;
      statusEl.textContent = 'Status: Off road';
    }

    // AI follow centerline
    const target = centerline[aiIndex];
    const aiDir = new THREE.Vector3(target.x - ai.position.x, 0, target.z - ai.position.z);
    if (aiDir.length() < 1.2) {
      aiIndex = (aiIndex + 1) % centerline.length;
    } else {
      aiDir.normalize();
      ai.position.addScaledVector(aiDir, aiSpeed * dt);
      ai.lookAt(ai.position.clone().add(aiDir));
    }

    renderer.render(scene, camera);
    requestAnimationFrame(animate);
  }

  statusEl.textContent = 'Status: Racing';
  animate();
  </script>
</body>
</html>
