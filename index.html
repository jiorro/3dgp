<!doctype html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <title>F1 3D - Prototype (HTML/CSS/JS)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    /* Layout base */
    html,body { height:100%; margin:0; background:#111; font-family:Arial,Helvetica,sans-serif; }
    #container { width:100%; height:100%; display:block; position:relative; overflow:hidden; }

    /* UI overlay */
    .ui {
      position: absolute; left:12px; top:12px; color:#fff; z-index:10;
      background:rgba(0,0,0,0.4); padding:10px 12px; border-radius:8px;
      box-shadow:0 4px 12px rgba(0,0,0,0.6);
    }
    .ui h1 { margin:0 0 6px 0; font-size:14px; font-weight:700; letter-spacing:0.5px; }
    .ui p { margin:4px 0; font-size:13px; }
    .ui .big { font-size:18px; font-weight:700; color:#ffd700; }

    /* Simple footer hint */
    .hint { position:absolute; right:12px; bottom:12px; color:#ddd; background:rgba(0,0,0,0.35); padding:8px 10px; border-radius:6px; font-size:12px; }

    /* Canvas will be injected by Three.js */
  </style>
</head>
<body>
  <div id="container"></div>

  <div class="ui" id="hud">
    <h1>F1 3D Prototype</h1>
    <p><span class="big" id="speed">Speed: 0 km/h</span></p>
    <p id="lap">Lap: 0 / 3</p>
    <p id="status">Status: Ready</p>
  </div>

  <div class="hint">Controls: W/S accelerate, A/D steer, Space brake</div>

  <!-- Three.js CDN -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.154.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.154.0/examples/js/controls/OrbitControls.js"></script>

  <script>
  // ====== Setup scena, renderer, camera ======
  const container = document.getElementById('container');
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x87ceeb); // cielo

  const renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.shadowMap.enabled = true;
  container.appendChild(renderer.domElement);

  const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
  camera.position.set(0, 6, -12);

  // Light
  const hemi = new THREE.HemisphereLight(0xffffff, 0x444444, 0.8);
  hemi.position.set(0, 50, 0);
  scene.add(hemi);

  const dir = new THREE.DirectionalLight(0xffffff, 0.8);
  dir.position.set(-10, 20, 10);
  dir.castShadow = true;
  dir.shadow.mapSize.set(2048,2048);
  scene.add(dir);

  // Ground / pista base
  const groundMat = new THREE.MeshStandardMaterial({ color: 0x2b2b2b });
  const ground = new THREE.Mesh(new THREE.PlaneGeometry(200, 200), groundMat);
  ground.rotation.x = -Math.PI/2;
  ground.receiveShadow = true;
  scene.add(ground);

  // ====== Pista semplice (anello) ======
  const track = new THREE.Group();
  scene.add(track);

  // Create a simple oval track using extruded shape
  const shape = new THREE.Shape();
  const rx = 30, rz = 18;
  for (let i=0;i<=64;i++){
    const t = (i/64)*Math.PI*2;
    const x = Math.cos(t)*rx;
    const z = Math.sin(t)*rz;
    if (i===0) shape.moveTo(x,z); else shape.lineTo(x,z);
  }
  const extrudeSettings = { steps: 64, depth: 6, bevelEnabled: false };
  const geometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);
  geometry.rotateX(-Math.PI/2);
  geometry.translate(0, 0.01, 0);
  const trackMat = new THREE.MeshStandardMaterial({ color: 0x444444 });
  const trackMesh = new THREE.Mesh(geometry, trackMat);
  trackMesh.receiveShadow = true;
  track.add(trackMesh);

  // Track centerline (for AI/waypoints)
  const centerline = [];
  for (let i=0;i<128;i++){
    const t = (i/128)*Math.PI*2;
    centerline.push(new THREE.Vector3(Math.cos(t)*rx, 0, Math.sin(t)*rz));
  }

  // Add simple curbs/edges
  const curbMat = new THREE.MeshStandardMaterial({ color: 0xff0000 });
  for (let i=0;i<64;i+=8){
    const p = centerline[i];
    const curb = new THREE.Mesh(new THREE.BoxGeometry(2,0.6,1), curbMat);
    curb.position.set(p.x, 0.3, p.z);
    curb.rotation.y = Math.random()*0.2;
    curb.castShadow = true;
    track.add(curb);
  }

  // ====== Auto (semplice) ======
  const car = new THREE.Group();
  car.position.set(0, 0.5, -rz - 5);
  scene.add(car);

  // Body
  const bodyMat = new THREE.MeshStandardMaterial({ color: 0x0055ff, metalness:0.3, roughness:0.4 });
  const body = new THREE.Mesh(new THREE.BoxGeometry(2.2,0.5,4), bodyMat);
  body.castShadow = true;
  body.position.y = 0.4;
  car.add(body);

  // Cockpit
  const cockpit = new THREE.Mesh(new THREE.BoxGeometry(1.2,0.4,1.2), new THREE.MeshStandardMaterial({ color:0x111111 }));
  cockpit.position.set(0,0.65,0.2);
  cockpit.castShadow = true;
  car.add(cockpit);

  // Wheels (visual only)
  const wheelMat = new THREE.MeshStandardMaterial({ color:0x111111 });
  function makeWheel(x,z){
    const w = new THREE.Mesh(new THREE.CylinderGeometry(0.35,0.35,0.4,16), wheelMat);
    w.rotation.z = Math.PI/2;
    w.position.set(x,0.2,z);
    w.castShadow = true;
    car.add(w);
    return w;
  }
  const wfl = makeWheel(-0.95,1.4);
  const wfr = makeWheel(0.95,1.4);
  const wrl = makeWheel(-0.95,-1.4);
  const wrr = makeWheel(0.95,-1.4);

  // ====== Camera follow parameters ======
  const camOffset = new THREE.Vector3(0, 4.2, -8);
  const camLookOffset = new THREE.Vector3(0, 1.2, 0);

  // ====== Simple driving physics (kinematic approximation) ======
  let velocity = 0; // m/s
  let heading = 0; // radians (car rotation around Y)
  let steerAngle = 0; // radians
  const maxSteer = THREE.MathUtils.degToRad(28);
  const maxSpeed = 80; // km/h
  const maxSpeedMs = maxSpeed / 3.6;
  const accel = 18; // m/s^2
  const brakeDecel = 40;
  const drag = 1.8; // air drag coefficient (tunable)
  const grip = 6.0; // turning responsiveness

  // Input state
  const input = { forward:false, back:false, left:false, right:false, brake:false };

  window.addEventListener('keydown', (e)=>{
    if (e.code === 'KeyW') input.forward = true;
    if (e.code === 'KeyS') input.back = true;
    if (e.code === 'KeyA') input.left = true;
    if (e.code === 'KeyD') input.right = true;
    if (e.code === 'Space') input.brake = true;
  });
  window.addEventListener('keyup', (e)=>{
    if (e.code === 'KeyW') input.forward = false;
    if (e.code === 'KeyS') input.back = false;
    if (e.code === 'KeyA') input.left = false;
    if (e.code === 'KeyD') input.right = false;
    if (e.code === 'Space') input.brake = false;
  });

  // HUD elements
  const speedEl = document.getElementById('speed');
  const lapEl = document.getElementById('lap');
  const statusEl = document.getElementById('status');

  // Lap detection: count passes near a start line
  const startLine = new THREE.Vector3(0,0, -rz - 5);
  let laps = 0;
  const totalLaps = 3;
  let lastCrossZ = car.position.z;

  // Simple AI opponent (follows centerline)
  const ai = new THREE.Group();
  scene.add(ai);
  const aiBody = new THREE.Mesh(new THREE.BoxGeometry(2.2,0.5,4), new THREE.MeshStandardMaterial({ color:0xff5500 }));
  aiBody.position.y = 0.4;
  ai.add(aiBody);
  ai.position.set(0,0.5, -rz - 12);
  let aiIndex = 0;
  let aiSpeed = 8;

  // Resize handling
  window.addEventListener('resize', ()=> {
    renderer.setSize(window.innerWidth, window.innerHeight);
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
  });

  // ====== Main loop ======
  const clock = new THREE.Clock();

  function animate(){
    const dt = Math.min(0.05, clock.getDelta()); // clamp dt for stability

    // --- Player input -> acceleration/braking ---
    let throttle = 0;
    if (input.forward) throttle += 1;
    if (input.back) throttle -= 0.6;

    // Apply acceleration
    if (input.brake) {
      // strong braking
      if (velocity > 0) velocity -= brakeDecel * dt;
      else velocity = Math.max(velocity - brakeDecel*dt, -maxSpeedMs*0.5);
    } else {
      velocity += throttle * accel * dt;
      // drag
      const dragForce = drag * velocity * Math.abs(velocity) * 0.02;
      velocity -= dragForce * dt;
    }

    // clamp speed
    velocity = THREE.MathUtils.clamp(velocity, -maxSpeedMs*0.6, maxSpeedMs);

    // steering input
    let steerInput = 0;
    if (input.left) steerInput = 1;
    if (input.right) steerInput = -1;
    // reduce max steer at high speed
    const speedFactor = 1 - Math.min(1, Math.abs(velocity)/maxSpeedMs);
    steerAngle = THREE.MathUtils.lerp(steerAngle, steerInput * maxSteer * (0.6 + 0.4*speedFactor), dt*6);

    // update heading and position (simple bicycle model approximation)
    const turnRadius = 1.0 / Math.max(0.0001, Math.tan(steerAngle));
    const angularVel = (velocity / Math.max(1, Math.abs(turnRadius))) * (steerAngle === 0 ? 0 : Math.sign(steerAngle));
    heading += angularVel * dt * (grip * 0.02);

    // move car forward in heading direction
    const forwardVec = new THREE.Vector3(Math.sin(heading), 0, Math.cos(heading));
    car.position.addScaledVector(forwardVec, velocity * dt);
    car.rotation.y = heading;

    // rotate wheels visually
    const wheelSpin = velocity * dt * 6;
    wfl.rotation.x -= wheelSpin;
    wfr.rotation.x -= wheelSpin;
    wrl.rotation.x -= wheelSpin;
    wrr.rotation.x -= wheelSpin;

    // Camera follow smoothing
    const desiredCamPos = car.localToWorld(camOffset.clone());
    camera.position.lerp(desiredCamPos, dt*4);
    const lookAt = car.localToWorld(camLookOffset.clone());
    camera.lookAt(lookAt);

    // Update HUD speed (km/h)
    const kmh = Math.round(velocity * 3.6);
    speedEl.textContent = `Speed: ${kmh} km/h`;

    // Lap detection: detect crossing start line (z coordinate threshold)
    const prevZ = lastCrossZ;
    lastCrossZ = car.position.z;
    // If car crosses from z < startLine.z to z > startLine.z near x ~ 0, count lap
    const crossThreshold = 3.0;
    if (prevZ < startLine.z && car.position.z >= startLine.z && Math.abs(car.position.x - startLine.x) < crossThreshold) {
      laps++;
      lapEl.textContent = `Lap: ${laps} / ${totalLaps}`;
      if (laps >= totalLaps) {
        statusEl.textContent = 'Status: Race Finished';
        // freeze car
        velocity = 0;
      } else {
        statusEl.textContent = `Status: Lap ${laps} completed`;
        setTimeout(()=> statusEl.textContent = 'Status: Racing', 1200);
      }
    }

    // Simple boundary check: keep car near track centerline radius; if too far, reduce speed (off-track penalty)
    const distFromCenter = Math.hypot(car.position.x, car.position.z);
    const trackRadius = Math.max(rx, rz) + 6;
    if (distFromCenter > trackRadius) {
      // off track: strong drag
      velocity *= 0.96;
      statusEl.textContent = 'Status: Off track';
    }

    // --- AI movement along centerline ---
    const target = centerline[aiIndex];
    const aiDir = new THREE.Vector3(target.x - ai.position.x, 0, target.z - ai.position.z);
    if (aiDir.length() < 1.2) {
      aiIndex = (aiIndex + 1) % centerline.length;
    } else {
      aiDir.normalize();
      ai.position.addScaledVector(aiDir, aiSpeed * dt);
      ai.lookAt(ai.position.clone().add(aiDir));
    }

    renderer.render(scene, camera);
    requestAnimationFrame(animate);
  }

  // Start
  statusEl.textContent = 'Status: Racing';
  animate();
  </script>
</body>
</html>
