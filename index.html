<!doctype html>
<html lang="it">
<head>
<meta charset="utf-8" />
<title>3D Track Editor - Integrato</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  html,body{height:100%;margin:0;background:#111;color:#fff;font-family:Arial,Helvetica,sans-serif}
  #container{width:100%;height:100%;position:relative;overflow:hidden}
  .panel{position:absolute;left:12px;top:12px;background:rgba(0,0,0,0.75);padding:10px;border-radius:8px;z-index:20;min-width:340px}
  .panel h3{margin:0 0 6px 0;font-size:14px}
  .panel button,input,label,select{margin:4px 2px;padding:6px;font-size:13px}
  .hint{position:absolute;right:12px;bottom:12px;background:rgba(0,0,0,0.35);padding:8px;border-radius:6px;font-size:12px;z-index:20}
  .small{font-size:12px;color:#ddd}
  .speed { position:absolute; right:12px; top:12px; z-index:21; background:rgba(0,0,0,0.6); padding:8px 10px; border-radius:8px; font-weight:700; color:#ffd700; display:none; }
  .modeBadge { position:absolute; left:12px; bottom:12px; z-index:21; background:rgba(0,0,0,0.6); padding:6px 8px; border-radius:6px; font-size:13px; }
  .row { display:flex; align-items:center; gap:6px; flex-wrap:wrap; }
  .panel .row > * { flex: none; }
</style>
</head>
<body>
<div id="container"></div>

<div class="panel" id="ui">
  <h3>Track Editor</h3>

  <div class="row">
    <button id="btnClear">Clear</button>
    <button id="btnSave">Save</button>
    <button id="btnLoad">Load</button>
    <button id="btnDownload">Download JSON</button>
    <input type="file" id="fileInput" accept=".json">
  </div>

  <div style="margin-top:6px" class="row">
    <label>Road Width <input id="roadWidth" type="number" value="7.2" step="0.2" style="width:80px"></label>
    <label>Wall Height <input id="wallHeight" type="number" value="2.0" step="0.1" style="width:80px"></label>
    <label>Wall Gap <input id="wallGap" type="number" value="1.2" step="0.1" style="width:80px"></label>
  </div>

  <div style="margin-top:6px" class="row">
    <label><input type="checkbox" id="autoWalls" checked> Auto Walls</label>
    <label><input type="checkbox" id="showRoad" checked> Show Road</label>
  </div>

  <div style="margin-top:6px" class="row">
    <button id="modePlaceWalls">Place Manual Walls</button>
    <button id="modePlaceBillboards">Place Billboards</button>
    <button id="modePlaceRoadWalls">Place Road Walls</button>
    <button id="modeSetSpawn">Set Spawn</button>
    <button id="btnTest">Test Track</button>
    <button id="btnEdit" disabled>Edit Track</button>
  </div>

  <div style="margin-top:8px" class="row">
    <strong>Editor Zoom</strong>
    <button id="zoomIn">+</button>
    <button id="zoomOut">−</button>
    <span class="small">o usa rotella / tasti + -</span>
  </div>

  <p class="small" style="margin-top:8px">Click per aggiungere punti; trascina per spostare; seleziona punto e premi Delete per rimuovere. Premi V per nascondere/mostrare il pannello.</p>
</div>

<div id="speedHud" class="speed">Speed: 0 km/h</div>
<div id="modeBadge" class="modeBadge">Editor</div>
<div class="hint">Controls: W/S accelerate/brake, A/D steer; Editor top-down; Test camera segue auto orizzontale</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.154.0/build/three.min.js"></script>

<script>
/* =========================
   Scena e variabili globali
   ========================= */
const container = document.getElementById('container');
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x87ceeb);
const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.shadowMap.enabled = true;
container.appendChild(renderer.domElement);

const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 2000);
camera.up.set(0,1,0); // up verticale
let editorHeight = 120; // altezza camera editor (top-down)
camera.position.set(0, editorHeight, 0);
camera.lookAt(0,0,0);

const hemi = new THREE.HemisphereLight(0xffffff,0x444444,0.9); hemi.position.set(0,50,0); scene.add(hemi);
const dir = new THREE.DirectionalLight(0xffffff,0.8); dir.position.set(-10,20,10); dir.castShadow=true; scene.add(dir);

const ground = new THREE.Mesh(new THREE.PlaneGeometry(2000,2000), new THREE.MeshStandardMaterial({color:0x2b2b2b}));
ground.rotation.x = -Math.PI/2; ground.receiveShadow = true; scene.add(ground);
const grass = new THREE.Mesh(new THREE.PlaneGeometry(2000,2000), new THREE.MeshStandardMaterial({color:0x2e8b57}));
grass.rotation.x = -Math.PI/2; grass.position.y = 0.001; scene.add(grass);

/* Editor state */
let mode = 'edit'; // 'edit' | 'test'
const points = [];
const pointMeshes = [];
let selectedPointIndex = -1;
let splineMesh = null;
let roadMesh = null;
let centerDashes = [];
const manualEntities = [];
let autoWallGroup = new THREE.Group(); scene.add(autoWallGroup);

/* Raycaster / input */
const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();
let dragging = false;
let dragIndex = -1;
const plane = new THREE.Plane(new THREE.Vector3(0,1,0), 0);

/* UI refs */
const btnClear = document.getElementById('btnClear');
const btnSave = document.getElementById('btnSave');
const btnLoad = document.getElementById('btnLoad');
const btnDownload = document.getElementById('btnDownload');
const fileInput = document.getElementById('fileInput');
const btnTest = document.getElementById('btnTest');
const btnEdit = document.getElementById('btnEdit');
const roadWidthInput = document.getElementById('roadWidth');
const wallHeightInput = document.getElementById('wallHeight');
const wallsToggle = document.getElementById('autoWalls');
const wallGapInput = document.getElementById('wallGap');
const modePlaceWalls = document.getElementById('modePlaceWalls');
const modePlaceBillboards = document.getElementById('modePlaceBillboards');
const modePlaceRoadWallsBtn = document.getElementById('modePlaceRoadWalls');
const modeSetSpawn = document.getElementById('modeSetSpawn');
const zoomInBtn = document.getElementById('zoomIn');
const zoomOutBtn = document.getElementById('zoomOut');
const showRoadCheckbox = document.getElementById('showRoad');
const speedHud = document.getElementById('speedHud');
const modeBadge = document.getElementById('modeBadge');

btnClear.onclick = () => { clearTrack(); renderEditor(); };
btnSave.onclick = () => { saveToLocal(); };
btnLoad.onclick = () => { loadFromLocal(); renderEditor(); };
btnDownload.onclick = () => { downloadJSON(); };
fileInput.onchange = (e)=> { loadFromFile(e); };
btnTest.onclick = ()=> { enterTestMode(); };
btnEdit.onclick = ()=> { enterEditMode(); };

modePlaceWalls.onclick = ()=> setPlaceMode('manualWall');
modePlaceBillboards.onclick = ()=> setPlaceMode('billboard');
modePlaceRoadWallsBtn.onclick = ()=> setPlaceMode('roadWall');
modeSetSpawn.onclick = ()=> setPlaceMode('setSpawn');

zoomInBtn.addEventListener('click', editorZoomIn);
zoomOutBtn.addEventListener('click', editorZoomOut);

/* Road material */
const roadMaterial = new THREE.MeshStandardMaterial({
  color: 0x555555,
  metalness: 0.05,
  roughness: 0.85,
  side: THREE.DoubleSide
});
const dashMaterial = new THREE.MeshStandardMaterial({color:0xffd24d});

/* =========================
   Funzioni editor: punti e mesh
   ========================= */
function addPointAt(x,z) {
  const p = new THREE.Vector3(x,0,z);
  points.push(p);
  const m = makePointMesh(p);
  pointMeshes.push(m);
  scene.add(m);
}

function makePointMesh(pos) {
  const g = new THREE.SphereGeometry(0.6,12,12);
  const mat = new THREE.MeshStandardMaterial({color:0xff0000});
  const m = new THREE.Mesh(g, mat);
  m.position.copy(pos);
  m.castShadow = true;
  return m;
}

function clearTrack() {
  for (let m of pointMeshes) scene.remove(m);
  pointMeshes.length = 0;
  points.length = 0;
  selectedPointIndex = -1;
  if (splineMesh) { scene.remove(splineMesh); splineMesh = null; }
  if (roadMesh) { scene.remove(roadMesh); roadMesh = null; }
  for (let d of centerDashes) scene.remove(d); centerDashes.length=0;
  while (autoWallGroup.children.length) autoWallGroup.remove(autoWallGroup.children[0]);
  for (let e of manualEntities) scene.remove(e.mesh);
  manualEntities.length = 0;
}

/* =========================
   Input mouse / posizionamento
   ========================= */
let placeMode = 'none'; // 'none'|'manualWall'|'billboard'|'setSpawn'|'roadWall'
let spawnT = 0.02;
let spawnPoint = null;

renderer.domElement.addEventListener('pointerdown', (ev)=>{
  const rect = renderer.domElement.getBoundingClientRect();
  mouse.x = ((ev.clientX - rect.left) / rect.width) * 2 - 1;
  mouse.y = -((ev.clientY - rect.top) / rect.height) * 2 + 1;
  raycaster.setFromCamera(mouse, camera);
  const intersect = new THREE.Vector3();
  raycaster.ray.intersectPlane(plane, intersect);

  if (mode === 'edit') {
    if (placeMode === 'manualWall') { placeManualEntity('wall', intersect); return; }
    if (placeMode === 'billboard') { placeManualEntity('billboard', intersect); return; }
    if (placeMode === 'setSpawn') {
      const curve = buildCurveFromPoints();
      if (!curve) { alert('Disegna prima il tracciato'); return; }
      spawnT = findClosestUOnCurve(curve, intersect);
      spawnPoint = curve.getPointAt(spawnT);
      alert('Spawn impostato');
      setPlaceMode('none');
      return;
    }
    if (placeMode === 'roadWall') {
      const curve = buildCurveFromPoints();
      if (!curve) { alert('Disegna prima il tracciato'); return; }
      const u = findClosestUOnCurve(curve, intersect);
      const p = curve.getPointAt(u);
      const tan = curve.getTangentAt(u).normalize();
      const left = new THREE.Vector3().crossVectors(new THREE.Vector3(0,1,0), tan).normalize();
      const gap = parseFloat(wallGapInput.value) || 1.2;
      const roadHalf = (parseFloat(roadWidthInput.value) || 7.2) / 2;
      const nearest = findNearestOnCenterline(p, curve.getPoints(200));
      const side = (nearest && nearest.lateral < 0) ? -1 : 1;
      const offset = left.clone().multiplyScalar(side * (roadHalf + gap));
      const pos = p.clone().add(offset);
      const wallH = parseFloat(wallHeightInput.value) || 2.0;
      const wallLen = 6;
      const wallThickness = 1.0;
      const box = new THREE.Mesh(new THREE.BoxGeometry(wallThickness, wallH, wallLen), new THREE.MeshStandardMaterial({color:0x666666}));
      box.position.copy(pos);
      box.lookAt(pos.clone().add(tan));
      box.position.y = wallH/2;
      scene.add(box);
      manualEntities.push({mesh: box, type:'roadWall', params:{height:wallH, length:wallLen, thickness:wallThickness, side}});
      renderEditor();
      return;
    }

    // seleziona o aggiungi punto
    let found = false;
    for (let i=0;i<pointMeshes.length;i++){
      const m = pointMeshes[i];
      const dist = m.position.distanceTo(intersect);
      if (dist < 1.2) {
        selectedPointIndex = i;
        dragging = true;
        dragIndex = i;
        found = true;
        break;
      }
    }
    if (!found) {
      addPointAt(intersect.x, intersect.z);
      renderEditor();
    }
  }
});

renderer.domElement.addEventListener('pointermove', (ev)=>{
  if (mode !== 'edit') return;
  if (!dragging) return;
  const rect = renderer.domElement.getBoundingClientRect();
  mouse.x = ((ev.clientX - rect.left) / rect.width) * 2 - 1;
  mouse.y = -((ev.clientY - rect.top) / rect.height) * 2 + 1;
  raycaster.setFromCamera(mouse, camera);
  const intersect = new THREE.Vector3();
  raycaster.ray.intersectPlane(plane, intersect);
  if (dragIndex >= 0) {
    points[dragIndex].x = intersect.x;
    points[dragIndex].z = intersect.z;
    pointMeshes[dragIndex].position.copy(points[dragIndex]);
    renderEditor();
  }
});

window.addEventListener('pointerup', ()=>{ dragging=false; dragIndex=-1; });

window.addEventListener('keydown', (e)=>{
  if (mode === 'edit') {
    if (e.key === 'Delete' || e.key === 'Backspace') {
      if (selectedPointIndex >= 0) {
        scene.remove(pointMeshes[selectedPointIndex]);
        pointMeshes.splice(selectedPointIndex,1);
        points.splice(selectedPointIndex,1);
        selectedPointIndex = -1;
        renderEditor();
      }
    }
    if (e.key === '+' || e.key === '=') editorZoomIn();
    if (e.key === '-') editorZoomOut();
  }
  if (e.key.toLowerCase() === 'v') {
    const panel = document.querySelector('.panel');
    if (panel) panel.style.display = panel.style.display === 'none' ? 'block' : 'none';
  }
});

/* Wheel zoom: solo altezza in editor */
renderer.domElement.addEventListener('wheel', (e)=>{
  if (mode === 'edit') {
    editorHeight = Math.max(20, Math.min(800, editorHeight + e.deltaY * 0.08));
    camera.position.set(0, editorHeight, 0);
    camera.lookAt(0,0,0);
    e.preventDefault();
    return;
  }
}, {passive:false});

/* =========================
   Render spline, strada, muri
   ========================= */
function renderEditor() {
  if (splineMesh) { scene.remove(splineMesh); splineMesh = null; }
  if (roadMesh) { scene.remove(roadMesh); roadMesh = null; }
  for (let d of centerDashes) scene.remove(d); centerDashes.length=0;
  while (autoWallGroup.children.length) autoWallGroup.remove(autoWallGroup.children[0]);

  if (points.length < 2) return;
  const curve = buildCurveFromPoints();
  if (!curve) return;

  const linePts = curve.getPoints(Math.max(64, points.length*12));
  const geom = new THREE.BufferGeometry().setFromPoints(linePts);
  const line = new THREE.Line(geom, new THREE.LineBasicMaterial({color:0xffff66}));
  splineMesh = line;
  scene.add(line);

  if (showRoadCheckbox.checked) {
    const width = parseFloat(roadWidthInput.value) || 7.2;
    const roadGeom = buildRoad(curve, width, 600);
    if (roadGeom) {
      roadMesh = new THREE.Mesh(roadGeom, roadMaterial);
      roadMesh.receiveShadow = true;
      roadMesh.position.y = 0.02; // evita z-fighting
      roadMesh.renderOrder = 1;
      scene.add(roadMesh);
    }
  }

  addCenterDashes(curve);

  if (wallsToggle.checked) {
    const wallH = parseFloat(wallHeightInput.value) || 2.0;
    const gap = parseFloat(wallGapInput.value) || 1.2;
    addAutoWalls(curve, (parseFloat(roadWidthInput.value)||7.2)/2 + gap, wallH, 1.0);
  }

  // mantieni camera top-down centrata in editor
  if (mode === 'edit') {
    camera.position.set(0, editorHeight, 0);
    camera.lookAt(0,0,0);
    camera.up.set(0,1,0);
  }
}

function buildRoad(curve, width, segments) {
  const geometry = new THREE.BufferGeometry();
  const positions = [];
  const normals = [];
  const uvs = [];
  const indices = [];
  const up = new THREE.Vector3(0,1,0);
  for (let i=0;i<=segments;i++){
    const t = i/segments;
    const p = curve.getPointAt(t);
    const tangent = curve.getTangentAt(t).normalize();
    const left = new THREE.Vector3().crossVectors(up, tangent).normalize();
    const half = width/2;
    const pl = p.clone().add(left.clone().multiplyScalar(half));
    const pr = p.clone().add(left.clone().multiplyScalar(-half));
    positions.push(pl.x, pl.y+0.02, pl.z);
    positions.push(pr.x, pr.y+0.02, pr.z);
    normals.push(0,1,0, 0,1,0);
    uvs.push(t*10,0, t*10,1);
    if (i<segments){
      const a = i*2, b = i*2+1, c = (i+1)*2, d = (i+1)*2+1;
      indices.push(a,c,b);
      indices.push(b,c,d);
    }
  }
  geometry.setIndex(indices);
  geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions,3));
  geometry.setAttribute('normal', new THREE.Float32BufferAttribute(normals,3));
  geometry.setAttribute('uv', new THREE.Float32BufferAttribute(uvs,2));
  geometry.computeBoundingBox();
  geometry.computeVertexNormals();
  return geometry;
}

function addCenterDashes(curve, dashLen=3, gap=2) {
  const totalLen = curve.getLength();
  let traveled = 0;
  while (traveled < totalLen) {
    const u = traveled / totalLen;
    const t = curve.getUtoTmapping(u);
    const p = curve.getPointAt(t);
    const tangent = curve.getTangentAt(t).normalize();
    const dash = new THREE.Mesh(new THREE.BoxGeometry(0.12,0.02,dashLen), dashMaterial);
    dash.position.copy(p).add(new THREE.Vector3(0,0.03,0));
    const yaw = Math.atan2(tangent.x, tangent.z);
    dash.rotation.y = yaw;
    scene.add(dash);
    centerDashes.push(dash);
    traveled += dashLen + gap;
  }
}

function addAutoWalls(curve, offsetX, height, thickness) {
  const segments = 200;
  for (let i=0;i<segments;i++){
    const t = i/segments;
    const p = curve.getPointAt(t);
    const tangent = curve.getTangentAt(t).normalize();
    const left = new THREE.Vector3().crossVectors(new THREE.Vector3(0,1,0), tangent).normalize();
    const posL = p.clone().add(left.clone().multiplyScalar(offsetX));
    const posR = p.clone().add(left.clone().multiplyScalar(-offsetX));
    const boxL = new THREE.Mesh(new THREE.BoxGeometry(thickness, height, 6), new THREE.MeshStandardMaterial({ color:0x666666 }));
    boxL.position.copy(posL); boxL.lookAt(posL.clone().add(tangent)); boxL.position.y = height/2;
    autoWallGroup.add(boxL);
    const boxR = boxL.clone();
    boxR.position.copy(posR); boxR.lookAt(posR.clone().add(tangent)); boxR.position.y = height/2;
    autoWallGroup.add(boxR);
  }
}

/* Manual entities */
function placeManualEntity(type, worldPos) {
  const h = parseFloat(wallHeightInput.value) || 2.0;
  const len = 6;
  if (type === 'wall') {
    const mesh = new THREE.Mesh(new THREE.BoxGeometry(1.0, h, len), new THREE.MeshStandardMaterial({color:0x777777}));
    mesh.position.copy(worldPos); mesh.position.y = h/2;
    scene.add(mesh);
    manualEntities.push({mesh, type:'wall', params:{height:h, length:len}});
  } else if (type === 'billboard') {
    const mesh = new THREE.Mesh(new THREE.BoxGeometry(0.6, 1.2, 0.2), new THREE.MeshStandardMaterial({color:0xffcc66}));
    mesh.position.copy(worldPos); mesh.position.y = 0.6;
    scene.add(mesh);
    manualEntities.push({mesh, type:'billboard', params:{height:1.2, length:0.2}});
  }
}

/* =========================
   Curve helpers
   ========================= */
function buildCurveFromPoints() {
  if (points.length < 2) return null;
  const pts = points.map(p=>p.clone());
  const closed = pts[0].distanceTo(pts[pts.length-1]) < 1.0;
  return new THREE.CatmullRomCurve3(pts, closed, 'catmullrom', 0.5);
}

function findClosestUOnCurve(curve, worldPos, samples=400) {
  let bestU = 0; let bestD = Infinity;
  for (let i=0;i<=samples;i++){
    const u = i/samples;
    const p = curve.getPointAt(u);
    const d = p.distanceTo(worldPos);
    if (d < bestD) { bestD = d; bestU = u; }
  }
  return bestU;
}

function findNearestOnCenterline(pos, centerlineArr) {
  let bestIdx = 0; let bestDist = Infinity;
  for (let i=0;i<centerlineArr.length;i++){
    const d = pos.distanceTo(centerlineArr[i]);
    if (d < bestDist) { bestDist = d; bestIdx = i; }
  }
  const next = centerlineArr[(bestIdx + 5) % centerlineArr.length];
  const prev = centerlineArr[(bestIdx - 5 + centerlineArr.length) % centerlineArr.length];
  const tangent = next.clone().sub(prev).normalize();
  const left = new THREE.Vector3().crossVectors(new THREE.Vector3(0,1,0), tangent).normalize();
  const vecToCar = pos.clone().sub(centerlineArr[bestIdx]);
  const lateral = vecToCar.dot(left);
  return { index: bestIdx, point: centerlineArr[bestIdx].clone(), tangent, lateral };
}

/* =========================
   Zoom functions (editor)
   ========================= */
function editorZoomIn() {
  editorHeight = Math.max(20, editorHeight - 8);
  camera.position.set(0, editorHeight, 0);
  camera.lookAt(0,0,0);
}
function editorZoomOut() {
  editorHeight = Math.min(800, editorHeight + 8);
  camera.position.set(0, editorHeight, 0);
  camera.lookAt(0,0,0);
}

/* =========================
   Save / Load
   ========================= */
function saveToLocal() {
  const data = {
    points: points.map(p=>({x:p.x,z:p.z})),
    roadWidth: parseFloat(roadWidthInput.value),
    wallHeight: parseFloat(wallHeightInput.value),
    wallsEnabled: wallsToggle.checked,
    wallGap: parseFloat(wallGapInput.value),
    manualEntities: manualEntities.map(e => ({
      type: e.type,
      pos: {x:e.mesh.position.x, y:e.mesh.position.y, z:e.mesh.position.z},
      params: e.params
    })),
    spawnT
  };
  localStorage.setItem('trackData', JSON.stringify(data));
  alert('Tracciato salvato');
}

function loadFromLocal() {
  const raw = localStorage.getItem('trackData');
  if (!raw) { alert('Nessun tracciato salvato'); return; }
  const data = JSON.parse(raw);
  applyTrackData(data);
}

function downloadJSON() {
  const data = {
    points: points.map(p=>({x:p.x,z:p.z})),
    roadWidth: parseFloat(roadWidthInput.value),
    wallHeight: parseFloat(wallHeightInput.value),
    wallsEnabled: wallsToggle.checked,
    wallGap: parseFloat(wallGapInput.value),
    manualEntities: manualEntities.map(e => ({
      type: e.type,
      pos: {x:e.mesh.position.x, y:e.mesh.position.y, z:e.mesh.position.z},
      params: e.params
    })),
    spawnT
  };
  const blob = new Blob([JSON.stringify(data, null, 2)], {type:'application/json'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url; a.download = 'track.json'; a.click();
  URL.revokeObjectURL(url);
}

function loadFromFile(e) {
  const f = e.target.files[0];
  if (!f) return;
  const reader = new FileReader();
  reader.onload = ()=> {
    const data = JSON.parse(reader.result);
    applyTrackData(data);
    renderEditor();
  };
  reader.readAsText(f);
}

function applyTrackData(data) {
  clearTrack();
  if (!data || !data.points) return;
  for (let pt of data.points) addPointAt(pt.x, pt.z);
  roadWidthInput.value = data.roadWidth || roadWidthInput.value;
  wallHeightInput.value = data.wallHeight || wallHeightInput.value;
  wallsToggle.checked = data.wallsEnabled !== undefined ? data.wallsEnabled : wallsToggle.checked;
  wallGapInput.value = data.wallGap !== undefined ? data.wallGap : wallGapInput.value;
  if (data.manualEntities && data.manualEntities.length) {
    for (let me of data.manualEntities) {
      const mesh = (me.type==='wall' || me.type==='roadWall') ? new THREE.Mesh(new THREE.BoxGeometry(1.0, me.params.height, me.params.length), new THREE.MeshStandardMaterial({color:0x777777}))
                                      : new THREE.Mesh(new THREE.BoxGeometry(0.6, me.params.height, me.params.length), new THREE.MeshStandardMaterial({color:0xffcc66}));
      mesh.position.set(me.pos.x, me.pos.y, me.pos.z);
      scene.add(mesh);
      manualEntities.push({mesh, type:me.type, params:me.params});
    }
  }
  spawnT = data.spawnT !== undefined ? data.spawnT : spawnT;
}

/* =========================
   Test mode: spawn, physics, pit limiter
   ========================= */
let player, ai, playerState, aiState, centerline = [], wallBoxes = [];
const TUNING = { accel:11.0, brakeDecel:90.0, drag:1.2, maxSpeedKmh:320 };

function enterTestMode() {
  if (points.length < 2) { alert('Disegna almeno 2 punti per il tracciato'); return; }
  mode = 'test';
  btnTest.disabled = true; btnEdit.disabled = false;
  for (let m of pointMeshes) m.visible = false;
  const curve = buildCurveFromPoints();
  centerline = [];
  const samples = 2400;
  for (let i=0;i<samples;i++){
    const t = i/samples;
    const p = curve.getPointAt(t);
    centerline.push(new THREE.Vector3(p.x,0,p.z));
  }
  wallBoxes = [];
  autoWallGroup.children.forEach(w => wallBoxes.push(new THREE.Box3().setFromObject(w)));
  manualEntities.forEach(e => wallBoxes.push(new THREE.Box3().setFromObject(e.mesh)));
  spawnVehicles(curve);

  // forza up verticale per evitare inclinazioni della camera in Test
  camera.up.set(0,1,0);

  speedHud.style.display = 'block';
  modeBadge.textContent = 'Test';
}

function enterEditMode() {
  mode = 'edit';
  btnTest.disabled = false; btnEdit.disabled = true;
  if (player) { scene.remove(player); player = null; }
  if (ai) { scene.remove(ai); ai = null; }
  for (let m of pointMeshes) m.visible = true;
  speedHud.style.display = 'none';
  modeBadge.textContent = 'Editor';
  // ripristina camera top-down editor
  camera.up.set(0,1,0);
  camera.position.set(0, editorHeight, 0);
  camera.lookAt(0,0,0);
}

/* spawn vehicles */
function spawnVehicles(curve) {
  if (player) scene.remove(player);
  if (ai) scene.remove(ai);

  player = new THREE.Group();
  const startT = spawnPoint ? findClosestUOnCurve(curve, spawnPoint) : spawnT;
  const startP = curve.getPointAt(startT);
  const startTan = curve.getTangentAt(startT).normalize();
  player.position.set(startP.x, 0.5, startP.z);
  player.rotation.y = Math.atan2(startTan.x, startTan.z);

  const bodyGeom = new THREE.BoxGeometry(2.2,0.5,4);
  const bodyMat = new THREE.MeshStandardMaterial({color:0x0055ff});
  const body = new THREE.Mesh(bodyGeom, bodyMat);
  body.position.y = 0.4; player.add(body);
  scene.add(player);

  ai = new THREE.Group();
  const aiT = (startT + 0.85) % 1.0;
  const aiP = curve.getPointAt(aiT);
  const aiTan = curve.getTangentAt(aiT).normalize();
  ai.position.set(aiP.x, 0.5, aiP.z);
  ai.rotation.y = Math.atan2(aiTan.x, aiTan.z);
  const aiBody = new THREE.Mesh(new THREE.BoxGeometry(2.2,0.5,4), new THREE.MeshStandardMaterial({color:0xff5500}));
  aiBody.position.y = 0.4; ai.add(aiBody);
  scene.add(ai);

  playerState = {velocity:0, heading:player.rotation.y, steerAngle:0, lapStartTime:performance.now(), lastLapAvgSpeed:null};
  aiState = {speed:8, index: Math.floor(centerline.length*0.85), targetSpeed:10};
}

/* Controls */
const input = {forward:false,back:false,left:false,right:false,brake:false};
window.addEventListener('keydown', (e)=>{
  if (mode !== 'test') return;
  if (e.code === 'KeyW' || e.code === 'ArrowUp') input.forward = true;
  if (e.code === 'KeyS' || e.code === 'ArrowDown') input.back = true;
  if (e.code === 'KeyA' || e.code === 'ArrowLeft') input.left = true;
  if (e.code === 'KeyD' || e.code === 'ArrowRight') input.right = true;
  if (e.code === 'Space') input.brake = true;
});
window.addEventListener('keyup', (e)=>{
  if (mode !== 'test') return;
  if (e.code === 'KeyW' || e.code === 'ArrowUp') input.forward = false;
  if (e.code === 'KeyS' || e.code === 'ArrowDown') input.back = false;
  if (e.code === 'KeyA' || e.code === 'ArrowLeft') input.left = false;
  if (e.code === 'KeyD' || e.code === 'ArrowRight') input.right = false;
  if (e.code === 'Space') input.brake = false;
});

/* Player physics (tuned) and pit limiter on grass */
function updatePlayerPhysics(dt) {
  if (!playerState || !player) return;

  const accel = TUNING.accel;           // m/s^2
  const brakeDecel = TUNING.brakeDecel;
  const drag = TUNING.drag;
  const maxSpeedMs = (TUNING.maxSpeedKmh || 320) / 3.6;

  let throttle = 0;
  if (input.forward && !input.back) throttle = 1;
  else if (input.back && !input.forward) throttle = -1;
  else throttle = 0;

  if (input.brake) {
    if (playerState.velocity > 0) playerState.velocity -= brakeDecel * dt;
    else playerState.velocity = Math.max(playerState.velocity - brakeDecel*dt, -maxSpeedMs*0.5);
  } else {
    playerState.velocity += throttle * accel * dt;
    const dragForce = drag * playerState.velocity * Math.abs(playerState.velocity) * 0.01;
    playerState.velocity -= dragForce * dt;
  }
  playerState.velocity = THREE.MathUtils.clamp(playerState.velocity, -maxSpeedMs*0.6, maxSpeedMs);

  let steerInput = 0;
  if (input.left && !input.right) steerInput = 1;
  else if (input.right && !input.left) steerInput = -1;
  else steerInput = 0;

  const maxSteer = THREE.MathUtils.degToRad(30);
  const speedFactor = 1 - Math.min(1, Math.abs(playerState.velocity) / (maxSpeedMs));
  const targetSteer = steerInput * maxSteer * (0.5 + 0.5 * speedFactor);
  playerState.steerAngle = THREE.MathUtils.lerp(playerState.steerAngle || 0, targetSteer, dt*8);

  const wheelbase = 2.6;
  const dHeading = (playerState.velocity / Math.max(0.0001, wheelbase)) * Math.tan(playerState.steerAngle || 0);
  playerState.heading += dHeading * dt;

  const forward = new THREE.Vector3(Math.sin(playerState.heading),0,Math.cos(playerState.heading));
  player.position.addScaledVector(forward, playerState.velocity * dt);
  player.rotation.y = playerState.heading;

  // pit limiter on grass: cap to 60 km/h if off-road
  if (centerline.length > 0) {
    const res = findNearestOnCenterline(player.position, centerline);
    const roadHalf = (parseFloat(roadWidthInput.value) || 7.2) / 2;
    const lateralAbs = Math.abs(res.lateral);
    if (lateralAbs > roadHalf) {
      const pitLimitMs = 60/3.6;
      if (playerState.velocity > pitLimitMs) playerState.velocity = pitLimitMs;
    }
  }

  player.position.y = 0.5;

  const kmh = Math.round(playerState.velocity * 3.6);
  speedHud.textContent = `Speed: ${kmh} km/h`;
}

/* AI */
function updateAIPhysics(dt) {
  if (!aiState || !ai) return;
  const lookahead = 18;
  let idx = aiState.index;
  const targetIdx = (idx + lookahead) % centerline.length;
  const target = centerline[targetIdx];
  const toTarget = new THREE.Vector3(target.x - ai.position.x, 0, target.z - ai.position.z);
  const dist = toTarget.length();
  if (dist < 1.2) aiState.index = (aiState.index + 1) % centerline.length;

  const desiredDir = toTarget.clone().normalize();
  const desiredYaw = Math.atan2(desiredDir.x, desiredDir.z);
  let yawDiff = Math.atan2(Math.sin(desiredYaw - ai.rotation.y), Math.cos(desiredYaw - ai.rotation.y));

  const playerAvg = (playerState && playerState.lastLapAvgSpeed) ? playerState.lastLapAvgSpeed : 12;
  const nextIdx = (targetIdx + 8) % centerline.length;
  const nextPoint = centerline[nextIdx];
  const futureDir = new THREE.Vector3(nextPoint.x - target.x, 0, nextPoint.z - target.z).normalize();
  const angleBetween = Math.acos(THREE.MathUtils.clamp(desiredDir.dot(futureDir), -1, 1));
  const curveFactor = Math.min(1, angleBetween / (Math.PI/4));
  const targetSpeed = THREE.MathUtils.lerp(playerAvg, 6, curveFactor);

  if (aiState.speed < targetSpeed) aiState.speed += 3.5 * dt;
  else aiState.speed -= 4.5 * dt;
  aiState.speed = THREE.MathUtils.clamp(aiState.speed, 4, Math.max(6, playerAvg*1.05));

  let avoid = false;
  const aiBox = new THREE.Box3().setFromObject(ai);
  for (let wb of wallBoxes) {
    const expanded = wb.clone().expandByScalar(1.6);
    if (aiBox.intersectsBox(expanded)) { avoid = true; break; }
  }
  if (avoid) {
    aiState.speed *= 0.6;
    yawDiff += (Math.random()>0.5?1:-1)*0.6;
  }

  const maxYawRate = dt * 3.0;
  yawDiff = THREE.MathUtils.clamp(yawDiff, -maxYawRate, maxYawRate);
  ai.rotation.y += yawDiff;

  const forward = new THREE.Vector3(Math.sin(ai.rotation.y),0,Math.cos(ai.rotation.y));
  ai.position.addScaledVector(forward, aiState.speed * dt);
  ai.position.y = 0.5;
}

/* =========================
   Animate: editor vs test camera behavior
   ========================= */
const clock = new THREE.Clock();
function animate(){
  const dt = Math.min(0.05, clock.getDelta());
  if (mode === 'edit') {
    renderer.render(scene, camera);
  } else {
    updatePlayerPhysics(dt);
    updateAIPhysics(dt);

    // camera follow stabile e orizzontale in Test
    if (player) {
      camera.up.set(0,1,0); // garantisce orizzontalità
      const followOffset = new THREE.Vector3(0, 6, -10);
      followOffset.applyAxisAngle(new THREE.Vector3(0,1,0), player.rotation.y);
      const desired = player.position.clone().add(followOffset);
      camera.position.lerp(desired, Math.min(1, dt * 3.0));
      const lookTarget = player.position.clone().add(new THREE.Vector3(0, 1, 0));
      camera.lookAt(lookTarget);
      camera.rotation.z = 0; // rimuove roll residuo
    }

    renderer.render(scene, camera);
  }
  requestAnimationFrame(animate);
}
animate();

/* =========================
   Inizializzazione sample track
   ========================= */
(function seedSample(){
  const sample = [
    {x:0,z:-220},{x:0,z:-160},{x:12,z:-130},{x:28,z:-100},{x:36,z:-60},
    {x:30,z:-20},{x:18,z:10},{x:6,z:36},{x:-6,z:60},{x:-28,z:80},
    {x:-48,z:60},{x:-56,z:20},{x:-48,z:-20},{x:-30,z:-60},{x:-12,z:-100},{x:6,z:-140},{x:0,z:-220}
  ];
  for (let p of sample) addPointAt(p.x,p.z);
  renderEditor();
  camera.position.set(0, editorHeight, 0);
  camera.lookAt(0,0,0);
})();

/* =========================
   Utility: setPlaceMode
   ========================= */
function setPlaceMode(m) {
  placeMode = m;
  if (m === 'manualWall') modeBadge.textContent = 'Place Manual Walls';
  else if (m === 'billboard') modeBadge.textContent = 'Place Billboards';
  else if (m === 'roadWall') modeBadge.textContent = 'Place Road Walls';
  else if (m === 'setSpawn') modeBadge.textContent = 'Set Spawn';
  else modeBadge.textContent = (mode==='edit' ? 'Editor' : 'Test');
}
</script>
</body>
</html>
