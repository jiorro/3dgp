<!doctype html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <title>F1 Cittadina - Monaco Style (Updated)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    html,body { height:100%; margin:0; background:#111; font-family:Arial,Helvetica,sans-serif; }
    #container { width:100%; height:100%; display:block; position:relative; overflow:hidden; }
    .ui {
      position: absolute; left:12px; top:12px; color:#fff; z-index:10;
      background:rgba(0,0,0,0.45); padding:10px 12px; border-radius:8px;
      box-shadow:0 4px 12px rgba(0,0,0,0.6);
    }
    .ui h1 { margin:0 0 6px 0; font-size:14px; font-weight:700; letter-spacing:0.5px; }
    .ui p { margin:4px 0; font-size:13px; }
    .ui .big { font-size:18px; font-weight:700; color:#ffd700; }
    .hint { position:absolute; right:12px; bottom:12px; color:#ddd; background:rgba(0,0,0,0.35); padding:8px 10px; border-radius:6px; font-size:12px; }
  </style>
</head>
<body>
  <div id="container"></div>

  <div class="ui" id="hud">
    <h1>F1 Cittadina - Monaco Style</h1>
    <p><span class="big" id="speed">Speed: 0 km/h</span></p>
    <p id="lap">Lap: 0 / 3</p>
    <p id="status">Status: Ready</p>
  </div>

  <div class="hint">Controls: W/S or ArrowUp/ArrowDown accelerate/brake, A/D or ArrowLeft/ArrowRight steer</div>

  <script src="https://cdn.jsdelivr.net/npm/three@0.154.0/build/three.min.js"></script>

  <script>
  // ====== Setup scena, renderer, camera ======
  const container = document.getElementById('container');
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x87ceeb);

  const renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.shadowMap.enabled = true;
  container.appendChild(renderer.domElement);

  const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 2000);
  camera.position.set(0, 2.2, 3); // iniziale, verrà aggiornato dalla camera sul cofano

  const hemi = new THREE.HemisphereLight(0xffffff, 0x444444, 0.9);
  hemi.position.set(0, 50, 0);
  scene.add(hemi);

  const dir = new THREE.DirectionalLight(0xffffff, 0.9);
  dir.position.set(-10, 20, 10);
  dir.castShadow = true;
  dir.shadow.mapSize.set(2048,2048);
  scene.add(dir);

  // ====== Ground and grass ======
  const groundMat = new THREE.MeshStandardMaterial({ color: 0x2b2b2b });
  const ground = new THREE.Mesh(new THREE.PlaneGeometry(2000, 2000), groundMat);
  ground.rotation.x = -Math.PI/2;
  ground.receiveShadow = true;
  scene.add(ground);

  const grassMat = new THREE.MeshStandardMaterial({ color: 0x2e8b57, roughness:1 });
  const grass = new THREE.Mesh(new THREE.PlaneGeometry(2000, 2000), grassMat);
  grass.rotation.x = -Math.PI/2;
  grass.position.y = 0.001;
  grass.receiveShadow = true;
  scene.add(grass);

  // ====== Monaco-inspired spline track (longer, tighter turns) ======
  const roadGroup = new THREE.Group();
  scene.add(roadGroup);

  const roadWidth = 7.2; // strada stretta come circuito cittadino
  // control points inspired to a street circuit with tight chicanes and hairpins
  const pts = [
    new THREE.Vector3(0,0,-220),
    new THREE.Vector3(0,0,-160),
    new THREE.Vector3(12,0,-130),
    new THREE.Vector3(28,0,-100),
    new THREE.Vector3(36,0,-60),
    new THREE.Vector3(30,0,-20),
    new THREE.Vector3(18,0,10),
    new THREE.Vector3(6,0,36),
    new THREE.Vector3(-6,0,60),
    new THREE.Vector3(-28,0,80),
    new THREE.Vector3(-48,0,60),
    new THREE.Vector3(-56,0,20),
    new THREE.Vector3(-48,0,-20),
    new THREE.Vector3(-30,0,-60),
    new THREE.Vector3(-12,0,-100),
    new THREE.Vector3(6,0,-140),
    new THREE.Vector3(0,0,-220) // chiude
  ];
  const curve = new THREE.CatmullRomCurve3(pts, true, 'catmullrom', 0.5);

  // build road mesh with more segments (più lungo e fluido)
  function buildRoad(curve, width, segments) {
    const geometry = new THREE.BufferGeometry();
    const positions = [];
    const normals = [];
    const uvs = [];
    const indices = [];
    const up = new THREE.Vector3(0,1,0);
    for (let i=0;i<=segments;i++){
      const t = i/segments;
      const p = curve.getPointAt(t);
      const tangent = curve.getTangentAt(t).normalize();
      const left = new THREE.Vector3().crossVectors(up, tangent).normalize();
      const half = width/2;
      const pl = p.clone().add(left.clone().multiplyScalar(half));
      const pr = p.clone().add(left.clone().multiplyScalar(-half));
      positions.push(pl.x, pl.y+0.02, pl.z);
      positions.push(pr.x, pr.y+0.02, pr.z);
      normals.push(0,1,0, 0,1,0);
      uvs.push(t*10,0, t*10,1);
      if (i<segments){
        const a = i*2, b = i*2+1, c = (i+1)*2, d = (i+1)*2+1;
        indices.push(a,c,b);
        indices.push(b,c,d);
      }
    }
    geometry.setIndex(indices);
    geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions,3));
    geometry.setAttribute('normal', new THREE.Float32BufferAttribute(normals,3));
    geometry.setAttribute('uv', new THREE.Float32BufferAttribute(uvs,2));
    geometry.computeBoundingBox();
    geometry.computeVertexNormals();
    return geometry;
  }

  const roadGeom = buildRoad(curve, roadWidth, 1400); // più segmenti = tracciato più lungo e fluido
  const asphaltMat = new THREE.MeshStandardMaterial({ color: 0x2f2f2f, roughness: 0.95 });
  const roadMesh = new THREE.Mesh(roadGeom, asphaltMat);
  roadMesh.receiveShadow = true;
  roadGroup.add(roadMesh);

  // center dashed line
  function addCenterDashes(curve, dashLen=3, gap=2) {
    const totalLen = curve.getLength();
    let traveled = 0;
    while (traveled < totalLen) {
      const u = traveled / totalLen;
      const t = curve.getUtoTmapping(u);
      const p = curve.getPointAt(t);
      const tangent = curve.getTangentAt(t).normalize();
      const dash = new THREE.Mesh(new THREE.BoxGeometry(0.12,0.02,dashLen), new THREE.MeshStandardMaterial({ color:0xffd24d, emissive:0xffd24d, emissiveIntensity:0.2 }));
      dash.position.copy(p).add(new THREE.Vector3(0,0.03,0));
      const yaw = Math.atan2(tangent.x, tangent.z);
      dash.rotation.y = yaw;
      roadGroup.add(dash);
      traveled += dashLen + gap;
    }
  }
  addCenterDashes(curve);

  // walls (più bassi) lungo il tracciato per effetto "street circuit"
  const walls = [];
  function addWallsAlongCurve(curve, offsetX, height, thickness) {
    const segments = 700;
    for (let i=0;i<segments;i++){
      const t = i/segments;
      const p = curve.getPointAt(t);
      const tangent = curve.getTangentAt(t).normalize();
      const left = new THREE.Vector3().crossVectors(new THREE.Vector3(0,1,0), tangent).normalize();
      const pos = p.clone().add(left.clone().multiplyScalar(offsetX));
      const box = new THREE.Mesh(new THREE.BoxGeometry(thickness, height, 6), new THREE.MeshStandardMaterial({ color:0x666666 }));
      box.position.copy(pos);
      box.lookAt(pos.clone().add(tangent));
      box.position.y = height/2;
      scene.add(box);
      walls.push(box);
    }
  }
  // muri più bassi per richiesta
  addWallsAlongCurve(curve, roadWidth/2 + 1.2, 2.0, 1.0);
  addWallsAlongCurve(curve, -(roadWidth/2 + 1.2), 2.0, 1.0);

  // decorative objects
  const crateMat = new THREE.MeshStandardMaterial({ color: 0x8b5a2b });
  for (let i=0;i<60;i++){
    const t = (i/60);
    const p = curve.getPointAt(t);
    const tangent = curve.getTangentAt(t).normalize();
    const left = new THREE.Vector3().crossVectors(new THREE.Vector3(0,1,0), tangent).normalize();
    const pos = p.clone().add(left.clone().multiplyScalar(roadWidth/2 + 2.2));
    const c = new THREE.Mesh(new THREE.BoxGeometry(1.0,0.7,1.0), crateMat);
    c.position.set(pos.x, 0.35, pos.z);
    scene.add(c);
    const pos2 = p.clone().add(left.clone().multiplyScalar(-(roadWidth/2 + 2.2)));
    const c2 = c.clone();
    c2.position.set(pos2.x, 0.35, pos2.z);
    scene.add(c2);
  }

  // ====== centerline samples for AI and lap detection ======
  const centerline = [];
  const samples = 2400;
  for (let i=0;i<samples;i++){
    const t = i/samples;
    const p = curve.getPointAt(t);
    centerline.push(new THREE.Vector3(p.x, 0, p.z));
  }

  // ====== Player car (spawn on track) ======
  const car = new THREE.Group();
  const startT = 0.02; // spawn t sulla spline
  const startPoint = curve.getPointAt(startT);
  const startTangent = curve.getTangentAt(startT).normalize();
  car.position.set(startPoint.x, 0.5, startPoint.z);
  car.rotation.y = Math.atan2(startTangent.x, startTangent.z);
  scene.add(car);

  const bodyMat = new THREE.MeshStandardMaterial({ color: 0x0055ff, metalness:0.3, roughness:0.4 });
  const body = new THREE.Mesh(new THREE.BoxGeometry(2.2,0.5,4), bodyMat);
  body.castShadow = true;
  body.position.y = 0.4;
  car.add(body);

  const cockpit = new THREE.Mesh(new THREE.BoxGeometry(1.2,0.4,1.2), new THREE.MeshStandardMaterial({ color:0x111111 }));
  cockpit.position.set(0,0.65,0.2);
  cockpit.castShadow = true;
  car.add(cockpit);

  const wheelMat = new THREE.MeshStandardMaterial({ color:0x111111 });
  function makeWheel(x,z){
    const w = new THREE.Mesh(new THREE.CylinderGeometry(0.35,0.35,0.4,16), wheelMat);
    w.rotation.z = Math.PI/2;
    w.position.set(x,0.2,z);
    w.castShadow = true;
    car.add(w);
    return w;
  }
  const wfl = makeWheel(-0.95,1.4);
  const wfr = makeWheel(0.95,1.4);
  const wrl = makeWheel(-0.95,-1.4);
  const wrr = makeWheel(0.95,-1.4);

  // ====== Camera on hood (muso visibile, prospettiva ravvicinata) ======
  // camOffset è in coordinate locali della macchina: z positivo = avanti
  const camOffset = new THREE.Vector3(0, 1.05, 2.2); // sul cofano, leggermente sopra il muso
  const camLookOffset = new THREE.Vector3(0, 0.6, 12); // guarda avanti lungo la strada

  // ====== Driving physics (bicycle model) ======
  let velocity = 0;
  let heading = car.rotation.y || 0;
  let steerAngle = 0;
  const maxSteer = THREE.MathUtils.degToRad(28);
  const maxSpeed = 160;
  const maxSpeedMs = maxSpeed / 3.6;
  const accel = 28;
  const brakeDecel = 80;
  const drag = 1.8;
  const wheelbase = 2.6;

  const input = { forward:false, back:false, left:false, right:false, brake:false };
  // supporto sia WASD che frecce
  window.addEventListener('keydown', (e)=>{
    if (e.code === 'KeyW' || e.code === 'ArrowUp') input.forward = true;
    if (e.code === 'KeyS' || e.code === 'ArrowDown') input.back = true;
    if (e.code === 'KeyA' || e.code === 'ArrowLeft') input.left = true;
    if (e.code === 'KeyD' || e.code === 'ArrowRight') input.right = true;
    if (e.code === 'Space') input.brake = true;
  });
  window.addEventListener('keyup', (e)=>{
    if (e.code === 'KeyW' || e.code === 'ArrowUp') input.forward = false;
    if (e.code === 'KeyS' || e.code === 'ArrowDown') input.back = false;
    if (e.code === 'KeyA' || e.code === 'ArrowLeft') input.left = false;
    if (e.code === 'KeyD' || e.code === 'ArrowRight') input.right = false;
    if (e.code === 'Space') input.brake = false;
  });

  const speedEl = document.getElementById('speed');
  const lapEl = document.getElementById('lap');
  const statusEl = document.getElementById('status');

  // Lap detection
  let laps = 0;
  const totalLaps = 3;
  let lastIndexOnLine = 0;

  // ====== AI car (spawn on track, veloce come il giocatore) ======
  const ai = new THREE.Group();
  scene.add(ai);
  const aiBody = new THREE.Mesh(new THREE.BoxGeometry(2.2,0.5,4), new THREE.MeshStandardMaterial({ color:0xff5500 }));
  aiBody.position.y = 0.4;
  ai.add(aiBody);
  // spawn AI qualche percentuale dietro il player sulla spline
  let aiT = (startT + 0.85) % 1.0;
  const aiStart = curve.getPointAt(aiT);
  const aiTangent = curve.getTangentAt(aiT).normalize();
  ai.position.set(aiStart.x, 0.5, aiStart.z);
  ai.rotation.y = Math.atan2(aiTangent.x, aiTangent.z);
  let aiIndex = Math.floor(centerline.length * 0.85);
  let aiSpeed = maxSpeedMs * 0.85; // inizialmente vicino al giocatore
  const aiMaxSpeed = maxSpeedMs * 0.98; // IA può raggiungere quasi la tua velocità
  const aiMinSpeed = 6;

  // Precompute wall bounding boxes
  const wallBoxes = [];
  function updateWallBoxes() {
    wallBoxes.length = 0;
    for (let w of walls) {
      const box = new THREE.Box3().setFromObject(w);
      wallBoxes.push(box);
    }
  }
  updateWallBoxes();

  // Resize handling
  window.addEventListener('resize', ()=> {
    renderer.setSize(window.innerWidth, window.innerHeight);
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
  });

  const clock = new THREE.Clock();

  // Player update using bicycle model (sterzo corretto)
  function updatePlayer(dt) {
    // throttle/brake
    let throttle = 0;
    if (input.forward) throttle += 1;
    if (input.back) throttle -= 0.6;

    if (input.brake) {
      if (velocity > 0) velocity -= brakeDecel * dt;
      else velocity = Math.max(velocity - brakeDecel * dt, -maxSpeedMs * 0.5);
    } else {
      velocity += throttle * accel * dt;
      const dragForce = drag * velocity * Math.abs(velocity) * 0.02;
      velocity -= dragForce * dt;
    }
    velocity = THREE.MathUtils.clamp(velocity, -maxSpeedMs * 0.6, maxSpeedMs);

    // steering input: left = -1, right = +1
    let steerInput = 0;
    if (input.left) steerInput = -1;
    if (input.right) steerInput = 1;

    // reduce steering at high speed
    const speedFactor = 1 - Math.min(1, Math.abs(velocity) / maxSpeedMs);
    const targetSteer = steerInput * maxSteer * (0.6 + 0.4 * speedFactor);
    steerAngle = THREE.MathUtils.lerp(steerAngle, targetSteer, dt * 8);

    // bicycle model: dHeading = v / L * tan(steerAngle)
    const dHeading = (velocity / Math.max(0.0001, wheelbase)) * Math.tan(steerAngle);
    heading += dHeading * dt;

    // move car forward according to heading
    const forwardVec = new THREE.Vector3(Math.sin(heading), 0, Math.cos(heading));
    car.position.addScaledVector(forwardVec, velocity * dt);
    car.rotation.y = heading;

    // wheel visuals
    const wheelSpin = velocity * dt * 6;
    wfl.rotation.x -= wheelSpin;
    wfr.rotation.x -= wheelSpin;
    wrl.rotation.x -= wheelSpin;
    wrr.rotation.x -= wheelSpin;
  }

  // AI update: pure pursuit with lookahead, now able to match player's speed
  function updateAI(dt) {
    if (centerline.length === 0) return;
    // find nearest index to AI (approx)
    let nearest = aiIndex;
    // lookahead index
    const lookahead = 22;
    let lookIndex = (nearest + lookahead) % centerline.length;
    const target = centerline[lookIndex];

    const toTarget = new THREE.Vector3(target.x - ai.position.x, 0, target.z - ai.position.z);
    const dist = toTarget.length();
    if (dist < 1.2) {
      aiIndex = (aiIndex + 1) % centerline.length;
      lookIndex = (aiIndex + lookahead) % centerline.length;
    }

    const desiredDir = toTarget.clone().normalize();
    const currentYaw = ai.rotation.y || 0;
    const desiredYaw = Math.atan2(desiredDir.x, desiredDir.z);
    let yawDiff = Math.atan2(Math.sin(desiredYaw - currentYaw), Math.cos(desiredYaw - currentYaw));

    // curvature estimate for speed control
    const nextIdx = (lookIndex + 8) % centerline.length;
    const nextPoint = centerline[nextIdx];
    const futureDir = new THREE.Vector3(nextPoint.x - target.x, 0, nextPoint.z - target.z).normalize();
    const angleBetween = Math.acos(THREE.MathUtils.clamp(desiredDir.dot(futureDir), -1, 1));
    const curveFactor = Math.min(1, angleBetween / (Math.PI/4));
    const targetSpeed = THREE.MathUtils.lerp(aiMaxSpeed, aiMinSpeed, curveFactor);

    // wall avoidance
    let avoid = 0;
    for (let wb of wallBoxes) {
      const expanded = wb.clone().expandByScalar(1.6);
      const aiBox = new THREE.Box3().setFromObject(ai);
      if (aiBox.intersectsBox(expanded)) {
        avoid = 1;
        break;
      }
    }

    // adjust aiSpeed smoothly toward targetSpeed (can reach player's speed)
    if (aiSpeed < targetSpeed) aiSpeed += 10 * dt;
    else aiSpeed -= 12 * dt;
    aiSpeed = THREE.MathUtils.clamp(aiSpeed, aiMinSpeed, aiMaxSpeed);

    if (avoid) {
      aiSpeed *= 0.55;
      yawDiff += (Math.random() > 0.5 ? 1 : -1) * 0.6;
    }

    // rotate gradually
    const maxYawRate = dt * 3.0;
    yawDiff = THREE.MathUtils.clamp(yawDiff, -maxYawRate, maxYawRate);
    ai.rotation.y += yawDiff;

    // move forward
    const moveForward = new THREE.Vector3(Math.sin(ai.rotation.y), 0, Math.cos(ai.rotation.y));
    ai.position.addScaledVector(moveForward, aiSpeed * dt);
  }

  // Collision detection and correction for player (muri)
  function handleCollisions() {
    const carBox = new THREE.Box3().setFromObject(car);
    let collided = false;
    for (let wb of wallBoxes) {
      if (carBox.intersectsBox(wb)) {
        collided = true;
        // push car back along its forward vector
        const forward = new THREE.Vector3(Math.sin(heading), 0, Math.cos(heading));
        car.position.addScaledVector(forward, -Math.max(0.08, Math.abs(velocity) * 0.02));
        velocity *= -0.18;
      }
    }
    // off-road penalty (grass) approximate
    let nearestDist = Infinity;
    for (let i=0;i<centerline.length;i+=12){
      const d = car.position.distanceTo(centerline[i]);
      if (d < nearestDist) nearestDist = d;
    }
    if (nearestDist > roadWidth/2 + 1.2) {
      velocity *= 0.96;
      statusEl.textContent = 'Status: On grass';
    } else if (!collided) {
      statusEl.textContent = 'Status: Racing';
    }
  }

  // Lap detection by progress along centerline
  function updateLap() {
    let nearest = 0;
    let best = Infinity;
    for (let i=0;i<centerline.length;i+=8){
      const d = car.position.distanceTo(centerline[i]);
      if (d < best) { best = d; nearest = i; }
    }
    if (nearest < lastIndexOnLine && lastIndexOnLine > centerline.length*0.8) {
      laps++;
      lapEl.textContent = `Lap: ${laps} / ${totalLaps}`;
      if (laps >= totalLaps) {
        statusEl.textContent = 'Status: Race Finished';
        velocity = 0;
      } else {
        statusEl.textContent = `Status: Lap ${laps} completed`;
        setTimeout(()=> statusEl.textContent = 'Status: Racing', 1200);
      }
    }
    lastIndexOnLine = nearest;
  }

  // Main loop
  function animate(){
    const dt = Math.min(0.05, clock.getDelta());

    updatePlayer(dt);
    handleCollisions();
    updateAI(dt);

    // camera on hood: compute world position from car local offset and look ahead
    const desiredCamPos = car.localToWorld(camOffset.clone());
    camera.position.lerp(desiredCamPos, dt*8);
    const lookAtWorld = car.localToWorld(camLookOffset.clone());
    camera.lookAt(lookAtWorld);

    // HUD
    const kmh = Math.round(velocity * 3.6);
    speedEl.textContent = `Speed: ${kmh} km/h`;

    updateLap();

    renderer.render(scene, camera);
    requestAnimationFrame(animate);
  }

  // initialize
  updateWallBoxes();
  statusEl.textContent = 'Status: Racing';
  animate();
  </script>
</body>
</html>

