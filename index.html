<!doctype html>
<html lang="it">
<head>
<meta charset="utf-8" />
<title>Track Editor Avanzato - Strada tra Muri, IA, Spawn, Pit Limiter</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  html,body{height:100%;margin:0;background:#111;color:#fff;font-family:Arial,Helvetica,sans-serif}
  #container{width:100%;height:100%;position:relative;overflow:hidden}
  .panel{position:absolute;left:12px;top:12px;background:rgba(0,0,0,0.7);padding:10px;border-radius:8px;z-index:12;min-width:320px}
  .panel h3{margin:0 0 6px 0;font-size:14px}
  .panel button,input,label,select{margin:4px 2px;padding:6px;font-size:13px}
  .hint{position:absolute;right:12px;bottom:12px;background:rgba(0,0,0,0.35);padding:8px;border-radius:6px;font-size:12px;z-index:12}
  #fileInput{display:none}
  .small{font-size:12px;color:#ddd}
  .speed { position:absolute; right:12px; top:12px; z-index:13; background:rgba(0,0,0,0.6); padding:8px 10px; border-radius:8px; font-weight:700; color:#ffd700; display:none; }
  .modeBadge { position:absolute; left:12px; bottom:12px; z-index:13; background:rgba(0,0,0,0.6); padding:6px 8px; border-radius:6px; font-size:13px; }
  .entityControls { margin-top:6px; border-top:1px solid rgba(255,255,255,0.06); padding-top:6px; }
  .row { display:flex; align-items:center; gap:6px; flex-wrap:wrap; }
</style>
</head>
<body>
<div id="container"></div>

<div class="panel" id="ui">
  <h3>Editor Avanzato</h3>

  <div class="row">
    <button id="btnClear">Clear</button>
    <button id="btnSave">Save</button>
    <button id="btnLoad">Load</button>
    <button id="btnDownload">Download JSON</button>
    <input type="file" id="fileInput" accept=".json">
  </div>

  <div style="margin-top:6px" class="row">
    <label>Road Width <input id="roadWidth" type="number" value="7.2" step="0.2" style="width:80px"></label>
    <label>Wall Height <input id="wallHeight" type="number" value="2.0" step="0.1" style="width:80px"></label>
    <label>Wall Gap <input id="wallGap" type="number" value="1.2" step="0.1" style="width:80px"></label>
  </div>

  <div style="margin-top:6px" class="row">
    <label><input type="checkbox" id="autoWalls" checked> Auto Walls</label>
    <label><input type="checkbox" id="showRoad" checked> Show Road</label>
  </div>

  <div style="margin-top:6px" class="row">
    <button id="modePlaceWalls">Place Manual Walls</button>
    <button id="modePlaceBillboards">Place Billboards</button>
    <button id="modeSetSpawn">Set Spawn</button>
    <button id="btnTest">Test Track</button>
    <button id="btnEdit" disabled>Edit Track</button>
  </div>

  <div class="entityControls" id="entityControls" style="display:none">
    <div class="small">Selected entity: <span id="selEntity">none</span></div>
    <div class="row">
      <label>Height <input id="entityHeight" type="number" value="2.0" step="0.1" style="width:80px"></label>
      <label>Length <input id="entityLength" type="number" value="6.0" step="0.1" style="width:80px"></label>
      <button id="applyEntity">Apply</button>
      <button id="deleteEntity">Delete</button>
    </div>
  </div>

  <div style="margin-top:8px" class="row">
    <strong>Editor Zoom</strong>
    <button id="zoomIn">+</button>
    <button id="zoomOut">−</button>
    <span class="small">o usa rotella / tasti + -</span>
  </div>

  <div style="margin-top:8px" class="row">
    <label>Upload hood image <input type="file" id="hoodImage" accept="image/*"></label>
    <span class="small">(verrà applicata come texture sulla carrozzeria)</span>
  </div>

  <p class="small" style="margin-top:8px">Click per aggiungere punti; trascina per spostare; seleziona punto e premi Delete per rimuovere. In modalità manual walls/billboards clicca per posizionare entità.</p>
</div>

<div id="speedHud" class="speed">Speed: 0 km/h</div>
<div id="modeBadge" class="modeBadge">Editor</div>
<div class="hint">Controls: W/S accelerate/brake, A/D steer; Middle click to change editor camera; Right-drag to orbit</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.154.0/build/three.min.js"></script>

<script>
/* =========================
   Setup scena e variabili
   ========================= */
const container = document.getElementById('container');
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x87ceeb);
const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.shadowMap.enabled = true;
container.appendChild(renderer.domElement);

const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 2000);
camera.up.set(0,1,0);

const hemi = new THREE.HemisphereLight(0xffffff,0x444444,0.9); hemi.position.set(0,50,0); scene.add(hemi);
const dir = new THREE.DirectionalLight(0xffffff,0.8); dir.position.set(-10,20,10); dir.castShadow=true; scene.add(dir);

const ground = new THREE.Mesh(new THREE.PlaneGeometry(2000,2000), new THREE.MeshStandardMaterial({color:0x2b2b2b}));
ground.rotation.x = -Math.PI/2; ground.receiveShadow = true; scene.add(ground);
const grass = new THREE.Mesh(new THREE.PlaneGeometry(2000,2000), new THREE.MeshStandardMaterial({color:0x2e8b57}));
grass.rotation.x = -Math.PI/2; grass.position.y = 0.001; scene.add(grass);

/* Editor state */
let mode = 'edit'; // 'edit' or 'test'
const points = [];
const pointMeshes = [];
let selectedPointIndex = -1;

let splineMesh = null;
let roadMesh = null;
let centerDashes = [];

const manualEntities = []; // array di {mesh, type:'wall'|'billboard', params}
let autoWallGroup = new THREE.Group(); scene.add(autoWallGroup);

const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();
let dragging = false;
let dragIndex = -1;
const plane = new THREE.Plane(new THREE.Vector3(0,1,0), 0);

/* UI refs */
const btnClear = document.getElementById('btnClear');
const btnSave = document.getElementById('btnSave');
const btnLoad = document.getElementById('btnLoad');
const btnDownload = document.getElementById('btnDownload');
const fileInput = document.getElementById('fileInput');
const btnTest = document.getElementById('btnTest');
const btnEdit = document.getElementById('btnEdit');
const roadWidthInput = document.getElementById('roadWidth');
const wallHeightInput = document.getElementById('wallHeight');
const wallsToggle = document.getElementById('autoWalls');
const wallGapInput = document.getElementById('wallGap');
const modePlaceWalls = document.getElementById('modePlaceWalls');
const modePlaceBillboards = document.getElementById('modePlaceBillboards');
const modeSetSpawn = document.getElementById('modeSetSpawn');
const entityControls = document.getElementById('entityControls');
const selEntityLabel = document.getElementById('selEntity');
const entityHeight = document.getElementById('entityHeight');
const entityLength = document.getElementById('entityLength');
const applyEntityBtn = document.getElementById('applyEntity');
const deleteEntityBtn = document.getElementById('deleteEntity');
const zoomInBtn = document.getElementById('zoomIn');
const zoomOutBtn = document.getElementById('zoomOut');
const hoodImageInput = document.getElementById('hoodImage');
const speedHud = document.getElementById('speedHud');
const modeBadge = document.getElementById('modeBadge');

btnClear.onclick = () => { clearTrack(); renderEditor(); };
btnSave.onclick = () => { saveToLocal(); };
btnLoad.onclick = () => { loadFromLocal(); renderEditor(); };
btnDownload.onclick = () => { downloadJSON(); };
fileInput.onchange = (e)=> { loadFromFile(e); };
btnTest.onclick = ()=> { enterTestMode(); };
btnEdit.onclick = ()=> { enterEditMode(); };

modePlaceWalls.onclick = ()=> { setPlaceMode('manualWall'); };
modePlaceBillboards.onclick = ()=> { setPlaceMode('billboard'); };
modeSetSpawn.onclick = ()=> { setPlaceMode('setSpawn'); };

applyEntityBtn.onclick = applyEntityChanges;
deleteEntityBtn.onclick = deleteSelectedEntity;
zoomInBtn.onclick = editorZoomIn;
zoomOutBtn.onclick = editorZoomOut;

/* Editor placement mode */
let placeMode = 'none'; // 'none' | 'manualWall' | 'billboard' | 'setSpawn'
let selectedEntity = null; // reference to manualEntities element
let spawnT = 0.02; // spawn parameter along curve (0..1)
let spawnPoint = null;

/* Road visuals */
const roadMaterial = new THREE.MeshStandardMaterial({color:0x3a3a3a, roughness:0.95}); // grigio strada
const dashMaterial = new THREE.MeshStandardMaterial({color:0xffd24d, emissive:0xffd24d, emissiveIntensity:0.2});

/* Car hood image texture (user upload) */
let hoodTexture = null;

/* Player and AI */
let player, ai, playerState, aiState;
let centerline = [];
let wallBoxes = []; // for AI simple avoidance
let lastLapTimes = []; // store lap times to compute average speed
let lapStartTime = null;
let lastLapIndex = 0;

/* Camera/editor controls */
let editorCameraIndex = 0;
const editorTop = {pos: new THREE.Vector3(0,120,0), look: new THREE.Vector3(0,0,0)};
const editorOrbit = {pos: new THREE.Vector3(0,60,120), look: new THREE.Vector3(0,0,0)};
const editorClose = {pos: new THREE.Vector3(0,18,60), look: new THREE.Vector3(0,0,0)};
let editorYaw = 0, editorPitch = 0, editorDistance = 120;
let orbitDragging = false, orbitLast = {x:0,y:0};

/* Initialize sample track */
(function seedSample(){
  const sample = [
    {x:0,z:-220},{x:0,z:-160},{x:12,z:-130},{x:28,z:-100},{x:36,z:-60},
    {x:30,z:-20},{x:18,z:10},{x:6,z:36},{x:-6,z:60},{x:-28,z:80},
    {x:-48,z:60},{x:-56,z:20},{x:-48,z:-20},{x:-30,z:-60},{x:-12,z:-100},{x:6,z:-140},{x:0,z:-220}
  ];
  for (let p of sample) addPointAt(p.x,p.z);
  renderEditor();
  editorCameraIndex = 0;
  applyEditorCameraImmediate();
})();

/* =========================
   Editor: add/drag points
   ========================= */
function addPointAt(x,z) {
  const p = new THREE.Vector3(x,0,z);
  points.push(p);
  const m = makePointMesh(p);
  pointMeshes.push(m);
  scene.add(m);
}

function makePointMesh(pos) {
  const g = new THREE.SphereGeometry(0.6,12,12);
  const mat = new THREE.MeshStandardMaterial({color:0xff0000});
  const m = new THREE.Mesh(g, mat);
  m.position.copy(pos);
  m.castShadow = true;
  return m;
}

renderer.domElement.addEventListener('pointerdown', (ev)=>{
  const rect = renderer.domElement.getBoundingClientRect();
  mouse.x = ((ev.clientX - rect.left) / rect.width) * 2 - 1;
  mouse.y = -((ev.clientY - rect.top) / rect.height) * 2 + 1;
  raycaster.setFromCamera(mouse, camera);
  const intersect = new THREE.Vector3();
  raycaster.ray.intersectPlane(plane, intersect);

  if (mode === 'edit') {
    // if placing manual entities or spawn
    if (placeMode === 'manualWall') {
      placeManualEntity('wall', intersect);
      return;
    } else if (placeMode === 'billboard') {
      placeManualEntity('billboard', intersect);
      return;
    } else if (placeMode === 'setSpawn') {
      // set spawnT to nearest t on curve
      if (!splineMesh) return;
      const curve = buildCurveFromPoints();
      if (!curve) return;
      const u = findClosestUOnCurve(curve, intersect);
      spawnT = u;
      spawnPoint = curve.getPointAt(u);
      alert('Spawn impostato sul tracciato');
      setPlaceMode('none');
      return;
    }
    // normal editor: select or add point
    let found = false;
    for (let i=0;i<pointMeshes.length;i++){
      const m = pointMeshes[i];
      const dist = m.position.distanceTo(intersect);
      if (dist < 1.2) {
        selectedPointIndex = i;
        dragging = true;
        dragIndex = i;
        found = true;
        break;
      }
    }
    if (!found) {
      addPointAt(intersect.x, intersect.z);
      renderEditor();
    }
  } else {
    // in test mode, maybe select manual entity for editing if clicked (allow editing while testing)
    // ignore for now
  }
});

renderer.domElement.addEventListener('pointermove', (ev)=>{
  if (mode !== 'edit') return;
  if (!dragging) return;
  const rect = renderer.domElement.getBoundingClientRect();
  mouse.x = ((ev.clientX - rect.left) / rect.width) * 2 - 1;
  mouse.y = -((ev.clientY - rect.top) / rect.height) * 2 + 1;
  raycaster.setFromCamera(mouse, camera);
  const intersect = new THREE.Vector3();
  raycaster.ray.intersectPlane(plane, intersect);
  if (dragIndex >= 0) {
    points[dragIndex].x = intersect.x;
    points[dragIndex].z = intersect.z;
    pointMeshes[dragIndex].position.copy(points[dragIndex]);
    renderEditor();
  }
});

window.addEventListener('pointerup', ()=>{ dragging=false; dragIndex=-1; });

window.addEventListener('keydown', (e)=>{
  if (mode === 'edit') {
    if (e.key === 'Delete' || e.key === 'Backspace') {
      if (selectedPointIndex >= 0) {
        scene.remove(pointMeshes[selectedPointIndex]);
        pointMeshes.splice(selectedPointIndex,1);
        points.splice(selectedPointIndex,1);
        selectedPointIndex = -1;
        renderEditor();
      }
    }
    if (e.key === '+' || e.key === '=') editorZoomIn();
    if (e.key === '-') editorZoomOut();
  }
});

/* =========================
   Render spline, road, walls
   ========================= */
function renderEditor() {
  // clear previous visuals
  if (splineMesh) { scene.remove(splineMesh); splineMesh = null; }
  if (roadMesh) { scene.remove(roadMesh); roadMesh = null; }
  for (let d of centerDashes) scene.remove(d); centerDashes.length = 0;
  // auto walls: remove only autoWallGroup children (keep manualEntities)
  while (autoWallGroup.children.length) {
    autoWallGroup.remove(autoWallGroup.children[0]);
  }

  if (points.length < 2) return;
  const curve = buildCurveFromPoints();
  if (!curve) return;

  // line
  const linePts = curve.getPoints(Math.max(64, points.length*12));
  const geom = new THREE.BufferGeometry().setFromPoints(linePts);
  const line = new THREE.Line(geom, new THREE.LineBasicMaterial({color:0xffff66}));
  splineMesh = line;
  scene.add(line);

  // road mesh (grigio) in mezzo ai muri
  if (document.getElementById('showRoad').checked) {
    const width = parseFloat(roadWidthInput.value) || 7.2;
    const roadGeom = buildRoad(curve, width, 600);
    roadMesh = new THREE.Mesh(roadGeom, roadMaterial);
    roadMesh.receiveShadow = true;
    scene.add(roadMesh);
  }

  // center dashes
  addCenterDashes(curve);

  // auto walls if enabled
  if (wallsToggle.checked) {
    const wallH = parseFloat(wallHeightInput.value) || 2.0;
    const gap = parseFloat(wallGapInput.value) || 1.2;
    addAutoWalls(curve, (parseFloat(roadWidthInput.value)||7.2)/2 + gap, wallH, 1.0);
  }
}

/* Build CatmullRom curve from points */
function buildCurveFromPoints() {
  if (points.length < 2) return null;
  const pts = points.map(p=>p.clone());
  const closed = pts[0].distanceTo(pts[pts.length-1]) < 1.0;
  return new THREE.CatmullRomCurve3(pts, closed, 'catmullrom', 0.5);
}

/* Road mesh builder */
function buildRoad(curve, width, segments) {
  const geometry = new THREE.BufferGeometry();
  const positions = [];
  const normals = [];
  const uvs = [];
  const indices = [];
  const up = new THREE.Vector3(0,1,0);
  for (let i=0;i<=segments;i++){
    const t = i/segments;
    const p = curve.getPointAt(t);
    const tangent = curve.getTangentAt(t).normalize();
    const left = new THREE.Vector3().crossVectors(up, tangent).normalize();
    const half = width/2;
    const pl = p.clone().add(left.clone().multiplyScalar(half));
    const pr = p.clone().add(left.clone().multiplyScalar(-half));
    positions.push(pl.x, pl.y+0.02, pl.z);
    positions.push(pr.x, pr.y+0.02, pr.z);
    normals.push(0,1,0, 0,1,0);
    uvs.push(t*10,0, t*10,1);
    if (i<segments){
      const a = i*2, b = i*2+1, c = (i+1)*2, d = (i+1)*2+1;
      indices.push(a,c,b);
      indices.push(b,c,d);
    }
  }
  geometry.setIndex(indices);
  geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions,3));
  geometry.setAttribute('normal', new THREE.Float32BufferAttribute(normals,3));
  geometry.setAttribute('uv', new THREE.Float32BufferAttribute(uvs,2));
  geometry.computeBoundingBox();
  geometry.computeVertexNormals();
  return geometry;
}

/* Center dashes */
function addCenterDashes(curve, dashLen=3, gap=2) {
  const totalLen = curve.getLength();
  let traveled = 0;
  while (traveled < totalLen) {
    const u = traveled / totalLen;
    const t = curve.getUtoTmapping(u);
    const p = curve.getPointAt(t);
    const tangent = curve.getTangentAt(t).normalize();
    const dash = new THREE.Mesh(new THREE.BoxGeometry(0.12,0.02,dashLen), dashMaterial);
    dash.position.copy(p).add(new THREE.Vector3(0,0.03,0));
    const yaw = Math.atan2(tangent.x, tangent.z);
    dash.rotation.y = yaw;
    scene.add(dash);
    centerDashes.push(dash);
    traveled += dashLen + gap;
  }
}

/* =========================
   Auto walls generation (keeps manualEntities intact)
   ========================= */
function addAutoWalls(curve, offsetX, height, thickness) {
  // create wall segments along curve and add to autoWallGroup
  const segments = 400;
  for (let i=0;i<segments;i++){
    const t = i/segments;
    const p = curve.getPointAt(t);
    const tangent = curve.getTangentAt(t).normalize();
    const left = new THREE.Vector3().crossVectors(new THREE.Vector3(0,1,0), tangent).normalize();
    const posL = p.clone().add(left.clone().multiplyScalar(offsetX));
    const posR = p.clone().add(left.clone().multiplyScalar(-offsetX));
    const boxL = new THREE.Mesh(new THREE.BoxGeometry(thickness, height, 6), new THREE.MeshStandardMaterial({ color:0x666666 }));
    boxL.position.copy(posL); boxL.lookAt(posL.clone().add(tangent)); boxL.position.y = height/2;
    autoWallGroup.add(boxL);
    const boxR = boxL.clone();
    boxR.position.copy(posR); boxR.lookAt(posR.clone().add(tangent)); boxR.position.y = height/2;
    autoWallGroup.add(boxR);
  }
}

/* =========================
   Manual entities (walls / billboards)
   - independent entities that do not affect auto walls
   - selectable and editable individually
   ========================= */
function placeManualEntity(type, worldPos) {
  // create entity mesh and push to manualEntities
  const h = parseFloat(wallHeightInput.value) || 2.0;
  const len = 6;
  if (type === 'wall') {
    const mesh = new THREE.Mesh(new THREE.BoxGeometry(1.0, h, len), new THREE.MeshStandardMaterial({color:0x777777}));
    mesh.position.copy(worldPos); mesh.position.y = h/2;
    scene.add(mesh);
    manualEntities.push({mesh, type:'wall', params:{height:h, length:len}});
    selectEntity(manualEntities[manualEntities.length-1]);
  } else if (type === 'billboard') {
    const mesh = new THREE.Mesh(new THREE.BoxGeometry(0.6, 1.2, 0.2), new THREE.MeshStandardMaterial({color:0xffcc66}));
    mesh.position.copy(worldPos); mesh.position.y = 0.6;
    scene.add(mesh);
    manualEntities.push({mesh, type:'billboard', params:{height:1.2, length:0.2}});
    selectEntity(manualEntities[manualEntities.length-1]);
  }
}

function selectEntity(entityObj) {
  selectedEntity = entityObj;
  selEntityLabel.textContent = entityObj ? entityObj.type : 'none';
  entityControls.style.display = entityObj ? 'block' : 'none';
  if (entityObj) {
    entityHeight.value = (entityObj.params.height || 1.0);
    entityLength.value = (entityObj.params.length || 1.0);
  }
}

function applyEntityChanges() {
  if (!selectedEntity) return;
  const h = parseFloat(entityHeight.value) || 1.0;
  const l = parseFloat(entityLength.value) || 1.0;
  selectedEntity.params.height = h;
  selectedEntity.params.length = l;
  // update mesh geometry (dispose old)
  const m = selectedEntity.mesh;
  scene.remove(m);
  let newGeom;
  if (selectedEntity.type === 'wall') newGeom = new THREE.BoxGeometry(1.0, h, l);
  else newGeom = new THREE.BoxGeometry(0.6, h, l);
  const mat = new THREE.MeshStandardMaterial({color: selectedEntity.type==='wall'?0x777777:0xffcc66});
  const newMesh = new THREE.Mesh(newGeom, mat);
  newMesh.position.copy(m.position);
  newMesh.rotation.copy(m.rotation);
  newMesh.position.y = h/2;
  scene.add(newMesh);
  selectedEntity.mesh = newMesh;
}

function deleteSelectedEntity() {
  if (!selectedEntity) return;
  scene.remove(selectedEntity.mesh);
  const idx = manualEntities.indexOf(selectedEntity);
  if (idx >= 0) manualEntities.splice(idx,1);
  selectEntity(null);
}

/* =========================
   Prevent auto walls duplication on repeated clicks
   - autoWallGroup is cleared and regenerated only when renderEditor runs
   - manualEntities are independent
   ========================= */

/* =========================
   Spawn, Test mode, Physics
   ========================= */
function enterTestMode() {
  if (points.length < 2) { alert('Disegna almeno 2 punti per il tracciato'); return; }
  mode = 'test';
  btnTest.disabled = true; btnEdit.disabled = false;
  for (let m of pointMeshes) m.visible = false;
  // build centerline samples
  const curve = buildCurveFromPoints();
  centerline = [];
  const samples = 2400;
  for (let i=0;i<samples;i++){
    const t = i/samples;
    const p = curve.getPointAt(t);
    centerline.push(new THREE.Vector3(p.x,0,p.z));
  }
  // compute wallBoxes for AI avoidance (auto walls + manual walls)
  wallBoxes = [];
  autoWallGroup.children.forEach(w => wallBoxes.push(new THREE.Box3().setFromObject(w)));
  manualEntities.forEach(e => wallBoxes.push(new THREE.Box3().setFromObject(e.mesh)));

  spawnVehicles(curve);
  speedHud.style.display = 'block';
  modeBadge.textContent = 'Test';
}

function enterEditMode() {
  mode = 'edit';
  btnTest.disabled = false; btnEdit.disabled = true;
  if (player) { scene.remove(player); player = null; }
  if (ai) { scene.remove(ai); ai = null; }
  for (let m of pointMeshes) m.visible = true;
  speedHud.style.display = 'none';
  modeBadge.textContent = 'Editor';
  editorCameraIndex = 0;
  applyEditorCameraImmediate();
}

/* spawn vehicles on curve; spawnT chosen in editor or default */
function spawnVehicles(curve) {
  if (player) scene.remove(player);
  if (ai) scene.remove(ai);

  // player group with body (car body uses hoodTexture if provided)
  player = new THREE.Group();
  const startT = spawnPoint ? findClosestUOnCurve(curve, spawnPoint) : spawnT;
  const startP = curve.getPointAt(startT);
  const startTan = curve.getTangentAt(startT).normalize();
  player.position.set(startP.x, 0.5, startP.z);
  player.rotation.y = Math.atan2(startTan.x, startTan.z);

  // body geometry: box with texture for hood (user image)
  const bodyGeom = new THREE.BoxGeometry(2.2,0.5,4);
  let bodyMat;
  if (hoodTexture) {
    bodyMat = new THREE.MeshStandardMaterial({map: hoodTexture});
  } else {
    bodyMat = new THREE.MeshStandardMaterial({color:0x0055ff});
  }
  const body = new THREE.Mesh(bodyGeom, bodyMat);
  body.position.y = 0.4; player.add(body);
  scene.add(player);

  // AI
  ai = new THREE.Group();
  const aiT = (startT + 0.85) % 1.0;
  const aiP = curve.getPointAt(aiT);
  const aiTan = curve.getTangentAt(aiT).normalize();
  ai.position.set(aiP.x, 0.5, aiP.z);
  ai.rotation.y = Math.atan2(aiTan.x, aiTan.z);
  const aiBody = new THREE.Mesh(new THREE.BoxGeometry(2.2,0.5,4), new THREE.MeshStandardMaterial({color:0xff5500}));
  aiBody.position.y = 0.4; ai.add(aiBody);
  scene.add(ai);

  // states
  playerState = {velocity:0, heading:player.rotation.y, steerAngle:0, lapIndex:0, lapStartTime:performance.now()};
  aiState = {speed:8, index: Math.floor(centerline.length*0.85), targetSpeed:10};

  // reset lap tracking
  lastLapTimes = [];
  lapStartTime = performance.now();
  lastLapIndex = 0;

  cameraMode = 'hood';
  applyCameraModeImmediate();
}

/* =========================
   Controls mapping and camera
   ========================= */
const input = {forward:false,back:false,left:false,right:false,brake:false};
window.addEventListener('keydown', (e)=>{
  if (mode !== 'test') return;
  if (e.code === 'KeyW' || e.code === 'ArrowUp') input.forward = true;
  if (e.code === 'KeyS' || e.code === 'ArrowDown') input.back = true;
  if (e.code === 'KeyA' || e.code === 'ArrowLeft') input.left = true;
  if (e.code === 'KeyD' || e.code === 'ArrowRight') input.right = true;
  if (e.code === 'Space') input.brake = true;
});
window.addEventListener('keyup', (e)=>{
  if (mode !== 'test') return;
  if (e.code === 'KeyW' || e.code === 'ArrowUp') input.forward = false;
  if (e.code === 'KeyS' || e.code === 'ArrowDown') input.back = false;
  if (e.code === 'KeyA' || e.code === 'ArrowLeft') input.left = false;
  if (e.code === 'KeyD' || e.code === 'ArrowRight') input.right = false;
  if (e.code === 'Space') input.brake = false;
});

/* Camera modes for Test */
let cameraMode = 'hood';
const hoodOffset = new THREE.Vector3(0,1.05,2.2);
const hoodLook = new THREE.Vector3(0,0.6,12);
const thirdOffset = new THREE.Vector3(0,3.6,-8.5);
const thirdLook = new THREE.Vector3(0,1.2,12);

function applyCameraModeImmediate() {
  if (!player) return;
  if (cameraMode === 'hood') {
    camera.position.copy(player.localToWorld(hoodOffset.clone()));
    camera.lookAt(player.localToWorld(hoodLook.clone()));
  } else if (cameraMode === 'third') {
    camera.position.copy(player.localToWorld(thirdOffset.clone()));
    camera.lookAt(player.localToWorld(thirdLook.clone()));
  } else if (cameraMode === 'top') {
    const topPos = player.position.clone().add(new THREE.Vector3(0,40,0));
    camera.position.copy(topPos);
    camera.lookAt(player.position.clone());
  }
}

function updateCameraSmooth(dt) {
  if (mode === 'edit') updateEditorCameraSmooth(dt);
  else {
    if (!player) return;
    if (cameraMode === 'hood') {
      const desired = player.localToWorld(hoodOffset.clone());
      camera.position.lerp(desired, dt*8);
      const look = player.localToWorld(hoodLook.clone());
      camera.lookAt(look);
    } else if (cameraMode === 'third') {
      const desired = player.localToWorld(thirdOffset.clone());
      camera.position.lerp(desired, dt*6);
      const look = player.localToWorld(thirdLook.clone());
      camera.lookAt(look);
    } else {
      const desired = player.position.clone().add(new THREE.Vector3(0,40,0));
      camera.position.lerp(desired, dt*4);
      camera.lookAt(player.position.clone());
    }
  }
}

/* Editor camera functions */
function applyEditorCameraImmediate() {
  if (editorCameraIndex === 0) {
    camera.position.copy(editorTop.pos);
    camera.lookAt(editorTop.look);
  } else if (editorCameraIndex === 1) {
    camera.position.copy(editorOrbit.pos);
    camera.lookAt(editorOrbit.look);
  } else {
    camera.position.copy(editorClose.pos);
    camera.lookAt(editorClose.look);
  }
}
function updateEditorCameraSmooth(dt) {
  if (editorCameraIndex === 0) {
    camera.position.lerp(editorTop.pos, dt*4);
    camera.lookAt(editorTop.look);
  } else if (editorCameraIndex === 1) {
    camera.position.lerp(editorOrbit.pos, dt*4);
    camera.lookAt(editorOrbit.look);
  } else {
    camera.position.lerp(editorClose.pos, dt*4);
    camera.lookAt(editorClose.look);
  }
}

/* Orbit controls in editor (right-drag) and middle click cycle */
renderer.domElement.addEventListener('contextmenu', (e)=>{ if (mode==='edit') e.preventDefault(); });
renderer.domElement.addEventListener('mousedown', (e)=>{
  if (e.button === 1) {
    if (mode === 'edit') {
      editorCameraIndex = (editorCameraIndex + 1) % 3;
      applyEditorCameraImmediate();
    } else {
      if (cameraMode === 'hood') cameraMode = 'third';
      else if (cameraMode === 'third') cameraMode = 'top';
      else cameraMode = 'hood';
      applyCameraModeImmediate();
    }
  }
  if (mode === 'edit' && e.button === 2) {
    orbitDragging = true;
    orbitLast.x = e.clientX; orbitLast.y = e.clientY;
  }
});
window.addEventListener('mousemove', (e)=>{
  if (mode === 'edit' && orbitDragging) {
    const dx = (e.clientX - orbitLast.x) * 0.005;
    const dy = (e.clientY - orbitLast.y) * 0.005;
    editorYaw += dx;
    editorPitch = Math.max(-1.2, Math.min(1.2, editorPitch + dy));
    orbitLast.x = e.clientX; orbitLast.y = e.clientY;
    const center = new THREE.Vector3(0,0,0);
    const x = Math.sin(editorYaw) * editorDistance * Math.cos(editorPitch);
    const y = Math.sin(editorPitch) * editorDistance;
    const z = Math.cos(editorYaw) * editorDistance * Math.cos(editorPitch);
    editorOrbit.pos.set(x, Math.max(6,y), z);
    editorOrbit.look.copy(center);
    applyEditorCameraImmediate();
  }
});
window.addEventListener('mouseup', ()=>{ orbitDragging = false; });

// zoom with wheel in editor
renderer.domElement.addEventListener('wheel', (e)=>{
  if (mode === 'edit') {
    editorDistance = Math.max(20, Math.min(400, editorDistance + e.deltaY * 0.1));
    const x = Math.sin(editorYaw) * editorDistance * Math.cos(editorPitch);
    const y = Math.sin(editorPitch) * editorDistance;
    const z = Math.cos(editorYaw) * editorDistance * Math.cos(editorPitch);
    editorOrbit.pos.set(x, Math.max(6,y), z);
    applyEditorCameraImmediate();
    e.preventDefault();
  }
}, {passive:false});

function editorZoomIn() {
  editorDistance = Math.max(20, editorDistance - 8);
  const x = Math.sin(editorYaw) * editorDistance * Math.cos(editorPitch);
  const y = Math.sin(editorPitch) * editorDistance;
  const z = Math.cos(editorYaw) * editorDistance * Math.cos(editorPitch);
  editorOrbit.pos.set(x, Math.max(6,y), z);
  applyEditorCameraImmediate();
}
function editorZoomOut() {
  editorDistance = Math.min(400, editorDistance + 8);
  const x = Math.sin(editorYaw) * editorDistance * Math.cos(editorPitch);
  const y = Math.sin(editorPitch) * editorDistance;
  const z = Math.cos(editorYaw) * editorDistance * Math.cos(editorPitch);
  editorOrbit.pos.set(x, Math.max(6,y), z);
  applyEditorCameraImmediate();
}

/* =========================
   Physics: player (F1-like) and AI following average speed
   ========================= */
function updatePlayerPhysics(dt) {
  if (!playerState) return;
  // F1-like parameters (tweakable)
  const maxSteer = THREE.MathUtils.degToRad(30);
  const wheelbase = 2.6;
  const maxSpeedMs = 340/3.6; // 340 km/h top unrealistic but cap
  const accel = 60; // strong acceleration (m/s^2)
  const brakeDecel = 120;
  const drag = 0.8;
  const grip = 6.0;

  // throttle/back exclusive
  let throttle = 0;
  if (input.forward && !input.back) throttle = 1;
  else if (input.back && !input.forward) throttle = -1;
  else throttle = 0;

  // apply throttle/brake
  if (input.brake) {
    if (playerState.velocity > 0) playerState.velocity -= brakeDecel * dt;
    else playerState.velocity = Math.max(playerState.velocity - brakeDecel*dt, -maxSpeedMs*0.5);
  } else {
    playerState.velocity += throttle * accel * dt;
    // aerodynamic drag
    const dragForce = drag * playerState.velocity * Math.abs(playerState.velocity) * 0.01;
    playerState.velocity -= dragForce * dt;
  }
  playerState.velocity = THREE.MathUtils.clamp(playerState.velocity, -maxSpeedMs*0.6, maxSpeedMs);

  // steering: A left, D right
  let steerInput = 0;
  if (input.left && !input.right) steerInput = 1;
  else if (input.right && !input.left) steerInput = -1;
  else steerInput = 0;

  const speedFactor = 1 - Math.min(1, Math.abs(playerState.velocity) / (maxSpeedMs));
  const targetSteer = steerInput * maxSteer * (0.5 + 0.5 * speedFactor);
  playerState.steerAngle = THREE.MathUtils.lerp(playerState.steerAngle || 0, targetSteer, dt*8);

  // bicycle model
  const dHeading = (playerState.velocity / Math.max(0.0001, wheelbase)) * Math.tan(playerState.steerAngle || 0);
  playerState.heading += dHeading * dt;

  // move
  const forward = new THREE.Vector3(Math.sin(playerState.heading),0,Math.cos(playerState.heading));
  player.position.addScaledVector(forward, playerState.velocity * dt);
  player.rotation.y = playerState.heading;

  // pit limiter on grass: if off-road (distance from centerline > roadHalf) cap to 60 km/h
  if (centerline.length > 0) {
    const res = findNearestOnCenterline(player.position, centerline);
    const roadHalf = (parseFloat(roadWidthInput.value) || 7.2) / 2;
    const lateralAbs = Math.abs(res.lateral);
    if (lateralAbs > roadHalf) {
      // on grass: cap speed to 60 km/h
      const pitLimitMs = 60/3.6;
      if (playerState.velocity > pitLimitMs) playerState.velocity = pitLimitMs;
    }
  }

  // keep constant height to avoid micro-dossi
  player.position.y = 0.5;

  // lap detection for average speed: approximate by centerline index
  if (centerline.length > 0) {
    const nearestIdx = findNearestIndexOnCenterline(player.position, centerline);
    // detect wrap-around
    if (nearestIdx < lastLapIndex && lastLapIndex > centerline.length*0.8) {
      // completed a lap
      const now = performance.now();
      const lapTime = (now - playerState.lapStartTime) / 1000.0; // seconds
      lastLapTimes.push(lapTime);
      playerState.lapStartTime = now;
      // compute average speed over last lap: track length / lapTime
      // approximate track length by centerline length in meters (sum of segments)
      const trackLen = computeCenterlineLength(centerline);
      playerState.lastLapAvgSpeed = trackLen / lapTime; // m/s
    }
    lastLapIndex = nearestIdx;
  }

  // update HUD speed
  const kmh = Math.round(playerState.velocity * 3.6);
  speedHud.textContent = `Speed: ${kmh} km/h`;
}

/* AI: pure pursuit but target speed = player's average lap speed (if available) */
function updateAIPhysics(dt) {
  if (!aiState) return;
  const lookahead = 18;
  let idx = aiState.index;
  const targetIdx = (idx + lookahead) % centerline.length;
  const target = centerline[targetIdx];
  const toTarget = new THREE.Vector3(target.x - ai.position.x, 0, target.z - ai.position.z);
  const dist = toTarget.length();
  if (dist < 1.2) aiState.index = (aiState.index + 1) % centerline.length;

  const desiredDir = toTarget.clone().normalize();
  const desiredYaw = Math.atan2(desiredDir.x, desiredDir.z);
  let yawDiff = Math.atan2(Math.sin(desiredYaw - ai.rotation.y), Math.cos(desiredYaw - ai.rotation.y));

  // curvature estimate for speed control
  const nextIdx = (targetIdx + 8) % centerline.length;
  const nextPoint = centerline[nextIdx];
  const futureDir = new THREE.Vector3(nextPoint.x - target.x, 0, nextPoint.z - target.z).normalize();
  const angleBetween = Math.acos(THREE.MathUtils.clamp(desiredDir.dot(futureDir), -1, 1));
  const curveFactor = Math.min(1, angleBetween / (Math.PI/4));
  // target speed: if player has lastLapAvgSpeed use it, else default
  const playerAvg = (playerState && playerState.lastLapAvgSpeed) ? playerState.lastLapAvgSpeed : 12; // m/s
  const targetSpeed = THREE.MathUtils.lerp(playerAvg, 6, curveFactor); // slow in curves

  // smooth speed
  if (aiState.speed < targetSpeed) aiState.speed += 6 * dt;
  else aiState.speed -= 8 * dt;
  aiState.speed = THREE.MathUtils.clamp(aiState.speed, 4, Math.max(6, playerAvg*1.05));

  // wall avoidance simple
  let avoid = false;
  const aiBox = new THREE.Box3().setFromObject(ai);
  for (let wb of wallBoxes) {
    const expanded = wb.clone().expandByScalar(1.6);
    if (aiBox.intersectsBox(expanded)) { avoid = true; break; }
  }
  if (avoid) {
    aiState.speed *= 0.6;
    yawDiff += (Math.random()>0.5?1:-1)*0.6;
  }

  // rotate gradually
  const maxYawRate = dt * 3.0;
  yawDiff = THREE.MathUtils.clamp(yawDiff, -maxYawRate, maxYawRate);
  ai.rotation.y += yawDiff;

  // move forward
  const forward = new THREE.Vector3(Math.sin(ai.rotation.y),0,Math.cos(ai.rotation.y));
  ai.position.addScaledVector(forward, aiState.speed * dt);

  // keep ai height constant
  ai.position.y = 0.5;
}

/* Helpers: nearest on centerline */
function findNearestOnCenterline(pos, centerlineArr) {
  let bestIdx = 0;
  let bestDist = Infinity;
  for (let i = 0; i < centerlineArr.length; i++) {
    const d = pos.distanceTo(centerlineArr[i]);
    if (d < bestDist) { bestDist = d; bestIdx = i; }
  }
  const next = centerlineArr[(bestIdx + 5) % centerlineArr.length];
  const prev = centerlineArr[(bestIdx - 5 + centerlineArr.length) % centerlineArr.length];
  const tangent = next.clone().sub(prev).normalize();
  const left = new THREE.Vector3().crossVectors(new THREE.Vector3(0,1,0), tangent).normalize();
  const vecToCar = pos.clone().sub(centerlineArr[bestIdx]);
  const lateral = vecToCar.dot(left);
  return { index: bestIdx, point: centerlineArr[bestIdx].clone(), tangent, lateral };
}
function findNearestIndexOnCenterline(pos, centerlineArr) {
  let bestIdx = 0; let bestDist = Infinity;
  for (let i=0;i<centerlineArr.length;i++){
    const d = pos.distanceTo(centerlineArr[i]);
    if (d < bestDist) { bestDist = d; bestIdx = i; }
  }
  return bestIdx;
}
function computeCenterlineLength(centerlineArr) {
  let len = 0;
  for (let i=1;i<centerlineArr.length;i++){
    len += centerlineArr[i].distanceTo(centerlineArr[i-1]);
  }
  // if closed add last->first
  len += centerlineArr[0].distanceTo(centerlineArr[centerlineArr.length-1]);
  return len;
}

/* find closest u on curve to world point (approx by sampling) */
function findClosestUOnCurve(curve, worldPos) {
  const samples = 200;
  let bestU = 0; let bestD = Infinity;
  for (let i=0;i<=samples;i++){
    const u = i/samples;
    const p = curve.getPointAt(u);
    const d = p.distanceTo(worldPos);
    if (d < bestD) { bestD = d; bestU = u; }
  }
  return bestU;
}

/* =========================
   Editor place mode helpers
   ========================= */
function setPlaceMode(m) {
  placeMode = m;
  // update UI badge
  if (m === 'manualWall') modeBadge.textContent = 'Place Manual Walls';
  else if (m === 'billboard') modeBadge.textContent = 'Place Billboards';
  else if (m === 'setSpawn') modeBadge.textContent = 'Set Spawn';
  else modeBadge.textContent = (mode==='edit' ? 'Editor' : 'Test');
}

/* =========================
   Hood image upload -> texture
   ========================= */
hoodImageInput.addEventListener('change', (e)=>{
  const f = e.target.files[0];
  if (!f) return;
  const reader = new FileReader();
  reader.onload = ()=> {
    const img = new Image();
    img.onload = ()=> {
      const tex = new THREE.Texture(img);
      tex.needsUpdate = true;
      hoodTexture = tex;
      // if player exists, apply immediately
      if (player) {
        player.traverse(c => { if (c.isMesh) c.material.map = hoodTexture; });
      }
      alert('Immagine cofano caricata e applicata');
    };
    img.src = reader.result;
  };
  reader.readAsDataURL(f);
});

/* =========================
   Save / Load track JSON
   ========================= */
function saveToLocal() {
  const data = {
    points: points.map(p=>({x:p.x,z:p.z})),
    roadWidth: parseFloat(roadWidthInput.value),
    wallHeight: parseFloat(wallHeightInput.value),
    wallsEnabled: wallsToggle.checked,
    wallGap: parseFloat(wallGapInput.value),
    manualEntities: manualEntities.map(e => ({
      type: e.type,
      pos: {x:e.mesh.position.x, y:e.mesh.position.y, z:e.mesh.position.z},
      params: e.params
    })),
    spawnT
  };
  localStorage.setItem('trackData', JSON.stringify(data));
  alert('Tracciato salvato in localStorage');
}

function loadFromLocal() {
  const raw = localStorage.getItem('trackData');
  if (!raw) { alert('Nessun tracciato salvato'); return; }
  const data = JSON.parse(raw);
  applyTrackData(data);
}

function downloadJSON() {
  const data = {
    points: points.map(p=>({x:p.x,z:p.z})),
    roadWidth: parseFloat(roadWidthInput.value),
    wallHeight: parseFloat(wallHeightInput.value),
    wallsEnabled: wallsToggle.checked,
    wallGap: parseFloat(wallGapInput.value),
    manualEntities: manualEntities.map(e => ({
      type: e.type,
      pos: {x:e.mesh.position.x, y:e.mesh.position.y, z:e.mesh.position.z},
      params: e.params
    })),
    spawnT
  };
  const blob = new Blob([JSON.stringify(data, null, 2)], {type:'application/json'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url; a.download = 'track.json'; a.click();
  URL.revokeObjectURL(url);
}

function loadFromFile(e) {
  const f = e.target.files[0];
  if (!f) return;
  const reader = new FileReader();
  reader.onload = ()=> {
    const data = JSON.parse(reader.result);
    applyTrackData(data);
    renderEditor();
  };
  reader.readAsText(f);
}

function applyTrackData(data) {
  // clear existing
  clearTrack();
  if (!data || !data.points) return;
  for (let pt of data.points) addPointAt(pt.x, pt.z);
  roadWidthInput.value = data.roadWidth || roadWidthInput.value;
  wallHeightInput.value = data.wallHeight || wallHeightInput.value;
  wallsToggle.checked = data.wallsEnabled !== undefined ? data.wallsEnabled : wallsToggle.checked;
  wallGapInput.value = data.wallGap !== undefined ? data.wallGap : wallGapInput.value;
  // manual entities
  if (data.manualEntities && data.manualEntities.length) {
    for (let me of data.manualEntities) {
      const mesh = (me.type==='wall') ? new THREE.Mesh(new THREE.BoxGeometry(1.0, me.params.height, me.params.length), new THREE.MeshStandardMaterial({color:0x777777}))
                                      : new THREE.Mesh(new THREE.BoxGeometry(0.6, me.params.height, me.params.length), new THREE.MeshStandardMaterial({color:0xffcc66}));
      mesh.position.set(me.pos.x, me.pos.y, me.pos.z);
      scene.add(mesh);
      manualEntities.push({mesh, type:me.type, params:me.params});
    }
  }
  spawnT = data.spawnT !== undefined ? data.spawnT : spawnT;
}

/* Clear track visuals and manual entities */
function clearTrack() {
  for (let m of pointMeshes) scene.remove(m);
  pointMeshes.length = 0;
  points.length = 0;
  selectedPointIndex = -1;
  if (splineMesh) { scene.remove(splineMesh); splineMesh = null; }
  if (roadMesh) { scene.remove(roadMesh); roadMesh = null; }
  for (let d of centerDashes) scene.remove(d); centerDashes.length = 0;
  // remove auto walls
  while (autoWallGroup.children.length) autoWallGroup.remove(autoWallGroup.children[0]);
  // remove manual entities
  for (let e of manualEntities) scene.remove(e.mesh);
  manualEntities.length = 0;
}

/* =========================
   Utility: set place mode and entity selection
   ========================= */
function setPlaceMode(modeStr) {
  placeMode = modeStr;
  if (modeStr === 'none') modeBadge.textContent = (mode==='edit' ? 'Editor' : 'Test');
  else if (modeStr === 'manualWall') modeBadge.textContent = 'Place Manual Walls';
  else if (modeStr === 'billboard') modeBadge.textContent = 'Place Billboards';
  else if (modeStr === 'setSpawn') modeBadge.textContent = 'Set Spawn';
}

/* =========================
   Animation loop
   ========================= */
const clock = new THREE.Clock();
function animate(){
  const dt = Math.min(0.05, clock.getDelta());
  if (mode === 'edit') {
    updateEditorCameraSmooth(dt);
    renderer.render(scene, camera);
  } else {
    updatePlayerPhysics(dt);
    updateAIPhysics(dt);
    updateCameraSmooth(dt);
    renderer.render(scene, camera);
  }
  requestAnimationFrame(animate);
}
animate();

/* =========================
   Small helpers used above
   ========================= */
function findClosestPointOnCurve(curve, worldPos, samples=400) {
  let best = {u:0, d:Infinity};
  for (let i=0;i<=samples;i++){
    const u = i/samples;
    const p = curve.getPointAt(u);
    const d = p.distanceTo(worldPos);
    if (d < best.d) { best.d = d; best.u = u; }
  }
  return best;
}

/* =========================
   End of file
   ========================= */
</script>
</body>
</html>
